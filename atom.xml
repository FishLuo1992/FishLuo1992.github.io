<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fish_need_sea</title>
  <icon>https://www.gravatar.com/avatar/abda6d8c22ea7f0b52720e09ea7f58e3</icon>
  <subtitle>no one</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fishluo1992.github.io/"/>
  <updated>2018-06-01T09:12:52.942Z</updated>
  <id>http://fishluo1992.github.io/</id>
  
  <author>
    <name>没尾巴的鱼</name>
    <email>18720090169@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue的MVVM</title>
    <link href="http://fishluo1992.github.io/2018/06/01/vue%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://fishluo1992.github.io/2018/06/01/vue的理解/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2018-06-01T09:12:52.942Z</updated>
    
    <content type="html"><![CDATA[<p>人生时苦，所以要做一个简单的人，<br>常想一二，不思八九，<br>越活越带感。  </p><h2 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h2><p>用过vue写过项目或者看过vue的同学在被问到“vue的响应式原理时”可能都会直接说：  Vue 是通过Object.defineProperty方法把data对象的全部属性转化成getter/setter，当属性被访问或者被修改时通知变化。  </p><p>Object.defineProperty的API的定义？这个就是ES5改变属性的值的一个API！这么回答肯定是有问题的，MDN的定义是：<br><em>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</em><br>再看vue官网介绍的响应式原理图。<br><img src="../../../../img/vue_prototype.jpg" alt="vue"><br> 首先通过渲染触发了Data的getter进行依赖收集，源码里有个一Deps订阅者，在数据变化时会通知所有的Watcher观察者，也就是说，在data变化时会触发它的setter，setter通知Watcher，Watcher通知组件执行Render Function，函数内再根据diff算法来实现视图的更新（render函数会根据内部的VDOM，也就是vue的虚拟DOM生成DOM树，diff就是新VDOM树与旧VDOM树进行深度对比(vue源码是比较新旧两个列表的vm的数据状态)，算出施加到真实DOM上的改动，然后通过createDocumentFragment创建对应的node节点）。  </p><h2 id="vue的MVVM实现"><a href="#vue的MVVM实现" class="headerlink" title="vue的MVVM实现"></a>vue的MVVM实现</h2><p>再分析vue的MVVM的实现  </p><p><img src="../../../../img/vue_mvvm.png" alt="vue_mvvm"><br>      new MVVM()也就是构造函数Vue的实例 new Vue()，是Vue的入口函数。<br>      Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可以通知订阅者。<br>      Watcher 订阅者，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。<br>      Compile 指令解析器，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据和绑定相应的更新数据。<br>      Dep 消息订阅器，Observer内部维护的一个数组，用来收集订阅者Wacher，数据变动触发notify函数，再调用订阅者的update方法。  </p><h3 id="new-MVVM"><a href="#new-MVVM" class="headerlink" title="new MVVM()"></a>new MVVM()</h3><p>vue源码内的英文注释都是尤大大加的，对于英文不好的我只能查字典了。<br>先看vue的<a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L107" target="_blank" rel="noopener">initData</a> 这个就是new Vue内初始化的数据，内部将数据进行Observer监听数据变化。    </p><pre><code>/*初始化data*/function initData (vm: Component) {  /*得到data数据*/  let data = vm.$options.data  data = vm._data = typeof data === &apos;function&apos;    ? getData(data, vm)    : data || {}  /*对对象类型进行严格检查，只有当对象是纯javascript对象的时候返回true*/  if (!isPlainObject(data)) {data = {}process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(  &apos;data functions should return an object:\n&apos; +  &apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;,  vm)}  // proxy data on instance  /*遍历data对象*/  const keys = Object.keys(data)  const props = vm.$options.props  let i = keys.length  //遍历data中的数据  while (i--) {/*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/if (props &amp;&amp; hasOwn(props, keys[i])) {  process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(    `The data property &quot;${keys[i]}&quot; is already declared as a prop. ` +    `Use prop default value instead.`,    vm  )} else if (!isReserved(keys[i])) {  /*判断是否是保留字段*/  /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/  proxy(vm, `_data`, keys[i])}      }      // observe data      /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/      observe(data, true /* asRootData */)    }    function getData (data: Function, vm: Component): any {      try {        return data.call(vm)      } catch (e) {        handleError(e, vm, `data()`)        return {}      }    }    </code></pre><p>内部的实现还是很复杂的，再说说proxy函数。     </p><pre><code>export function proxy (target: Object, sourceKey: string, key: string) {  sharedPropertyDefinition.get = function proxyGetter () {    return this[sourceKey][key]  }  sharedPropertyDefinition.set = function proxySetter (val) {    this[sourceKey][key] = val  }  Object.defineProperty(target, key, sharedPropertyDefinition)}</code></pre><p>代理函数，实现数据代理，<code>vm.options -&gt; vm._data.options</code>，可以理解为;     </p><pre><code>proxy: function(key, setter, getter) {    var me = this;    setter = setter ||     Object.defineProperty(_vm, key, {        configurable: false, //不能再define定义        enumerable: true,        get: function proxyGetter() {            return _vm._data[key];        },        set: function proxySetter(newVal) {            _vm._data[key] = newVal;        }    });},</code></pre><h3 id="Observer监听者"><a href="#Observer监听者" class="headerlink" title="Observer监听者"></a>Observer监听者</h3><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L34" target="_blank" rel="noopener">Oberver</a>的作用就是遍历对象的属性进行双向绑定。    </p><pre><code>export class Observer {  value: any;  dep: Dep;  vmCount: number; // number of vms that has this object as root $data  constructor (value: any) {    this.value = value    this.dep = new Dep()    this.vmCount = 0    /*    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16    */    def(value, &apos;__ob__&apos;, this)    if (Array.isArray(value)) {      /*          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。      */      const augment = hasProto        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/      augment(value, arrayMethods, arrayKeys)      /*Github:https://github.com/answershuto*/      /*如果是数组则需要遍历数组的每一个成员进行observe*/      this.observeArray(value)    } else {      /*如果是对象则直接walk进行绑定*/      this.walk(value)    }  }  /**   * Walk through each property and convert them into   * getter/setters. This method should only be called when   * value type is Object.   */  walk (obj: Object) {    const keys = Object.keys(obj)    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/    for (let i = 0; i &lt; keys.length; i++) {      defineReactive(obj, keys[i], obj[keys[i]])    }  }  /**   * Observe a list of Array items.   */  observeArray (items: Array&lt;any&gt;) {    /*数组需要便利每一个成员进行observe*/    for (let i = 0, l = items.length; i &lt; l; i++) {      observe(items[i])    }  }}</code></pre><p>defineReactive作用是通过defineProperty给数据定义getter\setter，当数据变动时通知Deps订阅器，映射给Watcher观察者对视图做变更。</p><pre><code>Object.defineProperty(obj, key, {    enumerable: true,    configurable: true,    get: function reactiveGetter () {      const value = getter ? getter.call(obj) : val      if (Dep.target) {        dep.depend()        if (childOb) {          childOb.dep.depend()          if (Array.isArray(value)) {            dependArray(value)          }        }      }      return value    },    set: function reactiveSetter (newVal) {      const value = getter ? getter.call(obj) : val      /* eslint-disable no-self-compare */      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {        return      }      /* eslint-enable no-self-compare */      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) {        customSetter()      }      if (setter) {        setter.call(obj, newVal)      } else {        val = newVal      }        // 如果是新值并且是object的话就进行监听      childOb = !shallow &amp;&amp; observe(newVal)      dep.notify() // 通知订阅者    }  })  </code></pre><h3 id="Deps订阅器"><a href="#Deps订阅器" class="headerlink" title="Deps订阅器"></a>Deps订阅器</h3><p>Deps订阅器的实现可以简单这样理解，就是数组subs  ，可以订阅多个观察者，依赖收集后Deps也会存在多个Watcher对象，在数据变更时通知所有的Watcher。</p><pre><code>var uid = 0;function Dep() {    this.id = uid++;    this.subs = []; // 这个就是订阅器}Dep.prototype = {    addSub: function(sub) {        this.subs.push(sub);    },    depend: function() {        Dep.target.addDep(this);    },    removeSub: function(sub) {        var index = this.subs.indexOf(sub);        if (index != -1) {            this.subs.splice(index, 1);        }    },    notify: function() {        this.subs.forEach(function(sub) {            sub.update();        });    }};</code></pre><h3 id="Watcher-观察者"><a href="#Watcher-观察者" class="headerlink" title="Watcher 观察者"></a>Watcher 观察者</h3><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js#L24" target="_blank" rel="noopener">Watcher</a>就是一个观察对象，依赖收集以后Watcher对象会被保存在Deps中。    </p><pre><code>export default class Watcher {  vm: Component;  expression: string;  cb: Function;  id: number;  deep: boolean;  user: boolean;  lazy: boolean;  sync: boolean;  dirty: boolean;  active: boolean;  deps: Array&lt;Dep&gt;;  newDeps: Array&lt;Dep&gt;;  depIds: ISet;  newDepIds: ISet;  getter: Function;  value: any;  constructor (    vm: Component,    expOrFn: string | Function,    cb: Function,    options?: Object  ) {    this.vm = vm    /*_watchers存放订阅者实例*/    vm._watchers.push(this)    // options    if (options) {      this.deep = !!options.deep      this.user = !!options.user      this.lazy = !!options.lazy      this.sync = !!options.sync    } else {      this.deep = this.user = this.lazy = this.sync = false    }    this.cb = cb    this.id = ++uid // uid for batching    this.active = true    this.dirty = this.lazy // for lazy watchers    this.deps = []    this.newDeps = []    this.depIds = new Set()    this.newDepIds = new Set()    this.expression = process.env.NODE_ENV !== &apos;production&apos;      ? expOrFn.toString()      : &apos;&apos;    // parse expression for getter    /*把表达式expOrFn解析成getter*/    if (typeof expOrFn === &apos;function&apos;) {      this.getter = expOrFn    } else {      this.getter = parsePath(expOrFn)      if (!this.getter) {        this.getter = function () {}        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(          `Failed watching path: &quot;${expOrFn}&quot; ` +          &apos;Watcher only accepts simple dot-delimited paths. &apos; +          &apos;For full control, use a function instead.&apos;,          vm        )      }    }    this.value = this.lazy      ? undefined      : this.get()  }  /**   * Evaluate the getter, and re-collect dependencies.   */   /*获得getter的值并且重新进行依赖收集*/  get () {    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/    pushTarget(this)    let value    const vm = this.vm    /*      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。      在将Dep.target设置为自生观察者实例以后，执行getter操作。      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，      那么在执行getter的时候就会触发a跟c两个数据的getter函数，      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，      将该观察者对象放入闭包中的Dep的subs中去。    */    if (this.user) {      try {        value = this.getter.call(vm, vm)      } catch (e) {        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)      }    } else {      value = this.getter.call(vm, vm)    }    // &quot;touch&quot; every property so they are all tracked as    // dependencies for deep watching    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/    if (this.deep) {      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/      traverse(value)    }    /*将观察者实例从target栈中取出并设置给Dep.target*/    popTarget()    this.cleanupDeps()    return value  }  /**   * Add a dependency to this directive.   */   /*添加一个依赖关系到Deps集合中*/  addDep (dep: Dep) {    const id = dep.id    if (!this.newDepIds.has(id)) {      this.newDepIds.add(id)      this.newDeps.push(dep)      if (!this.depIds.has(id)) {        dep.addSub(this)      }    }  }  /**   * Clean up for dependency collection.   */   /*清理依赖收集*/  cleanupDeps () {    /*移除所有观察者对象*/    let i = this.deps.length    while (i--) {      const dep = this.deps[i]      if (!this.newDepIds.has(dep.id)) {        dep.removeSub(this)      }    }    let tmp = this.depIds    this.depIds = this.newDepIds    this.newDepIds = tmp    this.newDepIds.clear()    tmp = this.deps    this.deps = this.newDeps    this.newDeps = tmp    this.newDeps.length = 0  }  /**   * Subscriber interface.   * Will be called when a dependency changes.   */   /*      调度者接口，当依赖发生改变的时候进行回调。   */  update () {    /* istanbul ignore else */     // 1. 每次调用run()的时候会触发相应属性的getter    // getter里面会触发dep.depend()，继而触发这里的addDep    // 2. 假如相应属性的dep.id已经在当前watcher的depIds里，说明不是一个新的属性，仅仅是改变了其值而已    // 则不需要将当前watcher添加到该属性的dep里    // 3. 假如相应属性是新的属性，则将当前watcher添加到新属性的dep里    // 如通过 vm.child = {name: &apos;a&apos;} 改变了 child.name 的值，child.name 就是个新属性    // 则需要将当前watcher(child.name)加入到新的 child.name 的dep里    // 因为此时 child.name 是个新值，之前的 setter、dep 都已经失效，如果不把 watcher 加入到新的 child.name 的dep中    // 通过 child.name = xxx 赋值的时候，对应的 watcher 就收不到通知，等于失效了    // 4. 每个子属性的watcher在添加到子属性的dep的同时，也会添加到父属性的dep    // 监听子属性的同时监听父属性的变更，这样，父属性改变时，子属性的watcher也能收到通知进行update    // 这一步是在 this.get() --&gt; this.getVMVal() 里面完成，forEach时会从父级开始取值，间接调用了它的getter    // 触发了addDep(), 在整个forEach过程，当前wacher都会加入到每个父级过程属性的dep    // 例如：当前watcher的是&apos;child.child.name&apos;, 那么child, child.child, child.child.name这三个属性的dep都会加入当前watcher    if (this.lazy) {      this.dirty = true    } else if (this.sync) {      /*同步则执行run直接渲染视图*/      this.run()    } else {      /*异步推送到观察者队列中，由调度者调用。*/      queueWatcher(this)    }  }  /**   * Scheduler job interface.   * Will be called by the scheduler.   */   /*      调度者工作接口，将被调度者回调。    */  run () {    if (this.active) {      const value = this.get()      if (        value !== this.value ||        // Deep watchers and watchers on Object/Arrays should fire even        // when the value is the same, because the value may        // have mutated.        /*            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。        */        isObject(value) ||        this.deep      ) {        // set new value        const oldValue = this.value        /*设置新的值*/        this.value = value        /*触发回调渲染视图*/        if (this.user) {          try {            this.cb.call(this.vm, value, oldValue)          } catch (e) {            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)          }        } else {          this.cb.call(this.vm, value, oldValue)        }      }    }  }  /**   * Evaluate the value of the watcher.   * This only gets called for lazy watchers.   */   /*获取观察者的值*/  evaluate () {    this.value = this.get()    this.dirty = false  }  /**   * Depend on all deps collected by this watcher.   */   /*收集该watcher的所有deps依赖*/  depend () {    let i = this.deps.length    while (i--) {      this.deps[i].depend()    }  }  /**   * Remove self from all dependencies&apos; subscriber list.   */   /*将自身从所有依赖收集订阅列表删除*/  teardown () {    if (this.active) {      // remove self from vm&apos;s watcher list      // this is a somewhat expensive operation so we skip it      // if the vm is being destroyed.      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/      if (!this.vm._isBeingDestroyed) {        remove(this.vm._watchers, this)      }      let i = this.deps.length      while (i--) {        this.deps[i].removeSub(this)      }      this.active = false    }  }}</code></pre><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p><a href="https://github.com/vuejs/vue/blob/dev/src/compiler/parser/index.js" target="_blank" rel="noopener">Compile</a>也就是指令解析器，这个和一般的模板引擎的区别都不大，大部分通过正则判断内部指令（普通指令和事件指令）。这个就简单说道这里。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要学到精髓还得多看看源码，看完也可以学到很多。整体架构，逻辑API的依赖等还需要仔细理解学习。<br>再次感谢尤大大！   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人生时苦，所以要做一个简单的人，&lt;br&gt;常想一二，不思八九，&lt;br&gt;越活越带感。  &lt;/p&gt;
&lt;h2 id=&quot;vue响应式原理&quot;&gt;&lt;a href=&quot;#vue响应式原理&quot; class=&quot;headerlink&quot; title=&quot;vue响应式原理&quot;&gt;&lt;/a&gt;vue响应式原理&lt;/h2
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://fishluo1992.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>奇怪的流程</title>
    <link href="http://fishluo1992.github.io/2018/05/31/vue%E7%9A%84%E5%B0%8F%E5%9D%91one/"/>
    <id>http://fishluo1992.github.io/2018/05/31/vue的小坑one/</id>
    <published>2018-05-31T11:47:45.000Z</published>
    <updated>2018-05-31T02:54:41.792Z</updated>
    
    <content type="html"><![CDATA[<h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p>  这是上一个项目了，公司内部的OA系统，页面近30个了，由我这个前端和一个java大神完成。总体时间也近两个月，接口的调试时间也占了很多，因为数据逻辑的耦合度太高了。<br>  下面谈谈一其中的个小需求吧！看图！  </p><p>  <img src="../../../../img/project_1.png" alt="js原型链"><br>  就是这种审批流程图，看起来比一般的线流程图多了一点样式。因为项目的模块不少，每个模块都有不同的审批流程，像这样  </p><p>   <img src="../../../../img/project_2.png" alt="js原型链">  </p><h2 id="解剖一下"><a href="#解剖一下" class="headerlink" title="解剖一下"></a>解剖一下</h2><p>   每个模块多个流程都需要看到这个流程走向，图像的上面是一个显示详细审批的信息列表。因为每个模块的流程图都不同，所有只能每个模块封装一个独有的组件来分别显示。 数据直接父组件传给子组件。 </p><p> <em>思考</em><br>  看到这样的设计图，直接简单粗暴的分析下。<br>  流程的显示有三种，分别是未开始、已处理和下一步处理，另外还有个驳回箭头。<br>  1.一般来讲，我们首先想到的会是用canvas来控制几种样式的逻辑<br>  2.另外还可以用JS+CSS来控制。  </p><p>   <em>动手</em><br> 嗯，canvas貌似也不错，在花了一个多小时画完这个图后，瞅瞅代码，这什么鬼。代码上百行，还没加逻辑判断，连自己看不下去了。再试试下个方案吧。<br> vue,可以类似JSP页面，HTML可以嵌套JS。那么逻辑控制显示就没问题了。那就得先把图画好了，圆和条子很简单，箭头也直接border画个三角形就OK了，不正规的菱形？两个三角形对立就OK了。  </p><pre><code>border-top: 5px solid transparent;border-bottom: 5px solid transparent;border-left: 5px solid #878787;  </code></pre><p>对的，就是这样。  </p><p><em>逻辑和数据处理</em><br>UI界面的图就这样完美出来了，是不难吧。嗯，只是开始。后台给我的接口只有一个数据seq来控制整个流程。对的，只有一个seq！！！ 我这边需要控制每个步骤图的三种不同的显示和驳回箭头的显示。   </p><p>嗯，不难，真的。只是多了点判断，像这样。  </p><pre><code> if(res.data.data.length &gt; 1 &amp;&amp; index == res.data.data.length-1){    if(arr[index].seq &lt; arr[index-1].seq){        if(arr[index-1].seq == 2){            that.ctrl = {&quot;step&quot;:Number(item.seq)-1,&quot;stop&quot;:1}        }else if(arr[index-1].seq == 5){            that.ctrl = {&quot;step&quot;:Number(item.seq)-1,&quot;stop&quot;:2}        }else if(arr[index-1].seq == 6){            that.ctrl = {&quot;step&quot;:Number(item.seq)-1,&quot;stop&quot;:3}        }else{            that.ctrl = {&quot;step&quot;:8,&quot;stop&quot;:0}        }                }else{        that.ctrl = {&quot;step&quot;:Number(item.seq),&quot;stop&quot;:0}    }    }else{    that.ctrl = {&quot;step&quot;:1,&quot;stop&quot;:0}}</code></pre><p>最终直接把ctrl传给子组件，参数是step和驳回的stop。那么接下来就是子组件控制流程的样式了，对的，这个也不难。<br>先取到数据  </p><pre><code>watch:{     ctrl:function(newval,oldval){             if(newval != oldval){                 this.getData()             }         } }, props:{     ctrl:{         type:Object,         default:function(){             return {};         }     } }</code></pre><p>因为一个模块内的每个流程都需要这个显示，所有需要watch一下保证数据完美的显示。  </p><p>##问题来了<br>数据有了，基本页面也完美展示了，那通过数据该咋渲染呢？<br>嗯，这个也不难。用来控制Class来控制就好，像这样  </p><pre><code>:class=&quot;step_t?&apos;ctrl-step-rebut&apos;:&apos;&apos;&quot;   </code></pre><p>是的这样可以控制两种，那这里有三种咋控制呢？这样？  </p><pre><code>:class=&quot;stepTwo?&apos;ctrl-first-right-writhe&apos;:(stepOne?&apos;ctrl-first-right-son&apos;:&apos;&apos;)&quot;  </code></pre><p>对的，就是这样，理论上三元表达式可以无限叠，但一般不会这样，万一其他人来维护这个项目呢，那不直接带刀找你了，所有两层就可以了，多层用if elseif来判断。<br>这样就可以完美的控制三种显示了。step 和 stop 也需要处理  </p><pre><code>switch (this.ctrl.step)           {               case 1:                 ...                break;                case 2:                ...                break;                 case 3:                ...                break;            }    switch (this.ctrl.stop){...}  </code></pre><p> 就这样，直接判断出流程走到哪一步，直接再通过显示哪里class来显示对应的样式就可以了。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.相比canvas来讲，用JS+css来解决这样流图更好，代码没那么复杂，能一看就懂，样式和一些逻辑也可以复用，清晰易懂。<br>2.业务都不难，难的是对底层代码的理解和自己实现业务逻辑的方法。每次碰到带点逻辑的业务还是需要仔细分析，保证自己能做到自己能做到的极限。<br>3.vue用起来还是很爽的，下一篇博客也来讲讲自己对vue的理解吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h4&gt;&lt;p&gt;  这是上一个项目了，公司内部的OA系统，页面近30个了，由我这个前端和一个java大神完成。总体时间也近两个月，接口的调试时间也占了很多，
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://fishluo1992.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>原型链的继承</title>
    <link href="http://fishluo1992.github.io/2018/05/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://fishluo1992.github.io/2018/05/28/原型链/</id>
    <published>2018-05-28T10:33:28.000Z</published>
    <updated>2018-05-30T08:48:12.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型链图-先上图"><a href="#原型链图-先上图" class="headerlink" title="原型链图(先上图)"></a>原型链图(先上图)</h2><p><img src="../../../../img/prototype_img.png" alt="js原型链">  </p><p>图片网上找的…</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="原型链的继承"><a href="#原型链的继承" class="headerlink" title="原型链的继承"></a>原型链的继承</h3><p>大家都知道面向对象有三大基本特性 ：封装、继承、多态。<br>继承是指让某个类型的对象获得另一个类型的对象的属性和方法。<br>而原型和原型链是Javascript实现继承的一种模型。<br>原型链的基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。<br>Javascript在创建对象的时候，都有一个叫做<strong>proto</strong>的内置属性，用于指向创建它的构造函数的原型对象，也就是图片上的prototype（这个属性指向原型对象，只有函数才有）。<br>每个对象都有<code>__proto__</code>属性，指向所继承的上层对象，最顶级是null;<br>从图上看，可以看到null的上一个指针是指向Object.prototype,也就是说,可以把Object看做是一个构造函数(其实它就是一个内置的构造函数)，其他的方法就是基于这个类型继承而来的。<br><code>var a = [];//这个同等于 var a = new Array();        var b = {}; // 同等于 var b = new Object();        console.log(a.__proto__ === Array.prototype) // true        console.log(b.__proto__ === Object.prototype) // true</code><br>我们发现a和b都有<code>__proto__</code>，分别指向了Array.prototype和Object.prototype。其实a,b都是内置的构造函数的实例对象，都基于类型分别继承了构造函数的prtotype。 </p><p>平常写的时候感觉很正常，其实像Array、Object这样的函数内置对象还有 Date、Function、RegExp、Json、Math。 </p><p>##构造函数  </p><p>只要创建一个新函数，就会根据规则给这个函数创建一个prototype属性，这个属性指向函数的原型对象。<br>也可以这样理解，所有函数对象都指向Function.prototype，都是Function的实例。<br><code>function Fn(){}  console.log(Fn.__proto__ === Function.prototype) //true</code><br>也就是说，<code>__proto__</code>存在于实例与构造函数原型对象之间，而不是存在于实例与构造函数之间。也可以理解为原型链的形成主要还是看<code>__proto__</code>，而不是prototype。<br>趁项目做完，忙里偷闲弄下博客（以前的总结都在txt里，哈哈）。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型链图-先上图&quot;&gt;&lt;a href=&quot;#原型链图-先上图&quot; class=&quot;headerlink&quot; title=&quot;原型链图(先上图)&quot;&gt;&lt;/a&gt;原型链图(先上图)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../../../../img/prototype_img.png&quot;
      
    
    </summary>
    
    
      <category term="JS" scheme="http://fishluo1992.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
