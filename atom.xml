<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fish_need_sea</title>
  <icon>https://www.gravatar.com/avatar/abda6d8c22ea7f0b52720e09ea7f58e3</icon>
  <subtitle>18720090169@163.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fishluo1992.github.io/"/>
  <updated>2018-09-27T10:53:17.701Z</updated>
  <id>http://fishluo1992.github.io/</id>
  
  <author>
    <name>没尾巴的鱼</name>
    <email>18720090169@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态生成匹配数字范围的正则表达式</title>
    <link href="http://fishluo1992.github.io/2018/08/09/%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E6%95%B0%E5%AD%97%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://fishluo1992.github.io/2018/08/09/动态生成数字正则表达式/</id>
    <published>2018-08-08T16:07:00.000Z</published>
    <updated>2018-09-27T10:53:17.701Z</updated>
    
    <content type="html"><![CDATA[<p><strong>起因</strong>      </p><hr><p>嗯~o(<em>￣▽￣</em>)o，项目是个基础框架，为了达到字段的动态配置。然后就有了这个 <strong>动态生成数字正则表达式的需求</strong>，老大还不忘对我说了句：“小伙子，看好你哦。”。嗯，好像就是这样！<br>如果静态的生成的数字范围的话，还是很简单的。但动态的第一次见，嗯，沉浸在挑战的亢奋中~！  </p><hr><p><strong>分析</strong>  </p><p>如果是范围的话，那就有最小和最大的,先从最大的入手。<br>1，动态生成正则的方法只有一种，使用new RegExp(string)的方法把string类型转换成regexp。<br>2，正则是匹配到每一个数字的，所以需要确定范围，比如100的范围有<br>\d \d\d 100 三种,123 有 \d \d\d 1[0-1][0-9] 1[0-2][0-3] 依次类推。需要生成的范围就容易确认。<br>3，通过遍历输入的数字长度和每个值来生成相应的字符串，最终拼接成完整的字符串，通过new RegExp来生成最终的正则。<br><strong>生成的最大值动态正则</strong>  </p><pre><code>function ruleMax(max, errorMessage) {  if (!Number(max)) return;  if (Number(max) &lt; 0) return;  let a = max + &apos;&apos;  let aStr = &apos;\^&apos; + a;  let b = []  let d = []  let middlePat = []  let finallyArr = []  let finallyReg = &apos;&apos;  let patMaxO = &apos;&apos;  let midS;  let reMax = {}  for (let i = 0, len = a.length; i &lt; len; i++) {    if (i &gt; 0) {      patMaxO += &apos;|\^&apos;      for (let j = 0; j &lt; i; j++) {        patMaxO += &apos;\\d&apos;      }      patMaxO += &apos;\$&apos;    }    b.push(&apos;[0-&apos; + a[i] + &apos;]&apos;)  }  for (let n = 0, len = b.length; n &lt; len; n++) {    middlePat = []    // 当为1的时候不能取 1 取0    // 当为0的时候也需要过滤掉    // 当大于1时，需要减1，尾数全可以匹配0-9    if(b[n].substr(3,1) == 1) {        middlePat.push(&apos;[0-0]&apos;)    }else if(b[n].substr(3,1) == 0) {        middlePat.push(&apos;[0-0]&apos;)    }else {        middlePat.push(&apos;[0-&apos; + (a[n]-1) + &apos;]&apos;)    }    for (let m = 0, leng = b.length; m &lt; leng; m++) {      if (m &gt; n &amp;&amp; b[n].substr(3,1) !== &apos;0&apos;) {        middlePat.push(&apos;[0-9]&apos;)      }else if(m &gt; n &amp;&amp; b[n].substr(3,1) === &apos;0&apos;) {        middlePat.push(&apos;[0-0]&apos;)      }    }    d.push(middlePat)  }  d.map(item =&gt; {      if (item.length &lt; b.length) {        let discrepancy = b.length - item.length        let AA = b.slice(0, discrepancy)        item = AA.concat(item)        finallyArr.push(item)      }    return true  })   // 去重  let resetArr = []  finallyArr.map(item =&gt; {    resetArr.push(item.join(&apos;&apos;))  })  let finPat = new Set(resetArr)  finPat.forEach((item) =&gt; {    finallyReg += &apos;\^&apos; + item + &apos;\$|&apos;  })  aStr += &apos;\$&apos; + patMaxO + &apos;\|&apos; + finallyReg.slice(0, finallyReg.length - 1)  const finMaxPat = new RegExp(aStr)  reMax.type = &apos;max&apos;  reMax.pattern = finMaxPat  reMax.message = errorMessage ? errorMessage : &apos;请输入小于&apos; + max + &apos;的正整数&apos;;  return reMax;}    </code></pre><p>这个是出版的生成最大值的正则，其中主要的问题是边界问题。<br>1.当生成最大正则时需要考虑0和1的情况，需要特殊处理。<br>2.当生成最小正则时，需要考虑9的情况。<br><strong>生成最小值的正则</strong>    </p><pre><code>function ruleMin(min, errorMessage) {  if (!Number(min)) return;  if (Number(min) &lt; 0) return;  let patMin = min + &apos;&apos;  patMin =  patMin.replace(/\b(0+)/gi,&quot;&quot;)  let patMinStr = &apos;\^&apos; + patMin  const patMinLength = patMin.length  let reMin = {}  let regArr = []  let patStr = []  let f = []  let finallyMinArr = []  let maxS;  let finallyMinReg = &apos;&apos;  for (let j = 0; j &lt; patMinLength; j++) {    patStr = []    if(Number(patMin[j]) === 9) {        patStr.push(&apos;[9-9]&apos;)    }else {        patStr.push(&apos;[&apos; + (Number(patMin[j]) + 1) + &apos;-9]&apos;)        for (let k = 0; k &lt; patMinLength; k++) {          if (k &lt;= j) {            continue;          } else {            patStr.push(&apos;[0-9]&apos;)          }        }    }    f.push(&apos;[&apos; + patMin[j] + &apos;-9]&apos;)    regArr.push(patStr)  }  regArr.map(item =&gt; {      if (item.length &lt; patMinLength) {        let minDiscrepancy = patMinLength - item.length        let addNum = f.slice(0, minDiscrepancy)        item = addNum.concat(item)        finallyMinArr.push(item)      } else {        finallyMinArr.push(item)      }    return true  })  let resetArr = []  finallyMinArr.map(item =&gt; {    resetArr.push(item.join(&apos;&apos;))  })  let finPat = new Set(resetArr)  finPat.forEach((item) =&gt; {    finallyMinReg += &apos;\^&apos; + item + &apos;\$|&apos;  })  patMinStr += &apos;\$|&apos; + finallyMinReg + &apos;\^\\d{&apos; + (patMinLength + 1) + &apos;,}&apos;  const finMinPat = new RegExp(patMinStr)  reMin.type = &apos;min&apos;  reMin.pattern = finMinPat  reMin.message = errorMessage ? errorMessage : &apos;请输入大于&apos; + min + &apos;的正整数&apos;  return reMin}    </code></pre><p>最终输出的内容<br><img src="../../../../img/regexp.png" alt="regexp">  </p><p><strong>总结</strong><br>嗯，多想想，明确好，规划好再写就OK啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;起因&lt;/strong&gt;      &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;嗯~o(&lt;em&gt;￣▽￣&lt;/em&gt;)o，项目是个基础框架，为了达到字段的动态配置。然后就有了这个 &lt;strong&gt;动态生成数字正则表达式的需求&lt;/strong&gt;，老大还不忘对我说了句：“小伙子，看好你
      
    
    </summary>
    
    
      <category term="JS" scheme="http://fishluo1992.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>在框架中使用的一些设计模式</title>
    <link href="http://fishluo1992.github.io/2018/07/25/%E5%9C%A8%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fishluo1992.github.io/2018/07/25/在框架中使用设计模式/</id>
    <published>2018-07-25T12:08:00.000Z</published>
    <updated>2018-09-19T10:23:51.757Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在框架中使用设计模式</strong></p><p> <strong>现在的一些框架封装的都很好，我们可以通过框架暴露的一些API就可以解决一般的业务需求。但项目比较大，内部的模块复用较多，需要自己架构，模块达到复用的效果，使用设计模式就可以更好地解决问题。</strong>    </p><p><strong>△有一点需要注意，绝对不要有为了用设计模式而用设计模式，代价很大。一切都是为了项目和需求，能简单粗暴就简单粗暴，不能为了想造轮子而去造轮子，是必要时才去使用。</strong></p><hr><p><strong>一、 构造函数模式的使用</strong><br>    <strong>大多数的业务场景都有用到，像一般的弹窗、提示一类的组件都用到了构造函数模式</strong>。<br>构造函数模式 是封装了一个类（也可以理解一个方法），内部通过this来管理自己的数据和方法，并return 需要暴露的参数或者方法。直接通过new fn（）来调用实例化对象。生产一个需要的方法。类似 vue封装的一些message，notify函数，内部封装完好，直接return new fn ，我们页不需要再写一遍new。直接调用就可以。<br>这种设计模式比较常规，用起来也是简单粗暴。</p><p><strong>二、 单列模式</strong><br>这个模式也很好理解，就是只返回一个需要的实例，没有 就创建一个实例返回。</p><pre><code>let Single = (function(){ var instance; function init() { //define private methods and properties //do something return {     //define public methods and properties }; } return { // 获取实例 getInstance:function(){     if(!instance){         instance = init(); } return instance;         }      } })();const obj1 = Single.getInstance();const obj2 = Single.getInstance(); console.log(obj1 === obj2); </code></pre><p>在平常使用框架时，如果需要在页面只显示或者只需要一个的时候，就可以通过这个设计模式来解决问题。<br>比如移动端的剧中弹窗，就可以通过这种方法来解决。</p><p><strong>三、 混合模式</strong><br>也就是 原型模式（prototype）和 构造函数模式的结合，这个也比较好理解</p><pre><code>import Vue from &apos;vue&apos;;import testTost from &quot;./toast.vue&quot;;const ToastConstructor = Vue.extend(testTost); let toastPool = [];let getAnInstance = () =&gt; {  if (toastPool.length &gt; 0) {    let instance = toastPool[0];    toastPool.splice(0, 1);    return instance;  }  return new ToastConstructor({    el: document.createElement(&apos;div&apos;)  });};let returnAnInstance = instance =&gt; {  if (instance) {    toastPool.push(instance);  }};let removeDom = event =&gt; {  if (event.target.parentNode) {    event.target.parentNode.removeChild(event.target);  }};// toast 的close方法ToastConstructor.prototype.close = function () {  this.visible = false;  this.$el.addEventListener(&apos;transitionend&apos;, removeDom);  this.closed = true;  returnAnInstance(this);};// Toast函数let Toast = (options = {}) =&gt; {  let duration = options.duration || 0;  // 实例对象  let instance = getAnInstance();  instance.closed = false;  clearTimeout(instance.timer); // 清除显示  // 实例的方法  instance.message = typeof options === &apos;string&apos; ? options : options.message;  instance.position = options.position || &apos;&apos;;  instance.className = options.className || &apos;&apos;;  instance.iconSrc = options.iconSrc || {};  // 挂载到body上  document.body.appendChild(instance.$el);  // 保证元素在DOM上  Vue.nextTick(function () {    instance.visible = true;    instance.$el.removeEventListener(&apos;transitionend&apos;, removeDom);    if (duration) {      instance.timer = setTimeout(function () {        if (instance.closed) return;        instance.close();      }, duration);    }  });  return instance;};// 使插件可以全局调用function MineToast() {  Vue.$toast = Vue.prototype.$toast = Toast;}export default MineToast;    </code></pre><p>混合模式中构造函数模式用于定义实例属性,而原型模式用于定义方法和共享属性. 每个实例都会有自己的一份实例属性,但同时又共享这方法,最大限度的节省了内存.另外这种模式还支持传递初始数据.优点胜多,这种模式使用广泛,认同度最高的一种创建自定义对象的方法.</p><p>在这个封装的插件组件内部，运用了混合模式、单例模式。保证了实例的单一，达到需要的效果。 </p><p><strong>四、 动态原型模式</strong><br>动态原型模式将所有信息封装在了构造函数中,而通过构造函数中初始化原型,这个可以通过判断该方法是否有效而选择是否需要初始化原型.<br>可以举一个我组件react项目中的例子。<br>    // fromFactory.js<br>    import {Fld_Type} from ‘../dataTable/fldType’<br>    import CommonField from ‘./commonField’<br>    import ReadField from ‘./readField’<br>    import EnumField from ‘./enumField’<br>    import SingleImage from ‘./singleImage’<br>    import MutilImage from ‘./mutilImage’<br>    import React from ‘react’<br>    import cloneDeep from ‘lodash.clonedeep’</p><pre><code>export function buildEditField(form,name,value,props,viewName,reverse){switch(props.vtype) {    case Fld_Type.type_common:        return React.createElement(CommonField,{form:form,name:name,value:value,fieldProps:props,target:viewName,reverse:reverse})    case Fld_Type.type_read:        return React.createElement(ReadField,{form:form,name:name,value:value,fieldProps:props,target:viewName,reverse:reverse})    case Fld_Type.type_queryone:    case Fld_Type.type_querylist:    case Fld_Type.type_enum:        return React.createElement(EnumField,{form:form,name:name,value:value,fieldProps:props,target:viewName,reverse:reverse})    default:        return React.createElement(CommonField,{form:form,name:name,value:value,fieldProps:props,target:viewName,reverse:reverse})    }}</code></pre><p>这些是封装的一些通用的表单子组件，在使用可以直接通过调用函数来构建需求的组件，最终组成一个From表单。    </p><pre><code>const reactElement = buildAddField(form,item[0],item[1],this.props.viewName,{moniterItem:moniterItem});    </code></pre><p>在项目中也可以封装通用的Icon配置。<br>    import styles from ‘./index.less’;<br>    import React from ‘react’<br>    import { Icon } from ‘antd’</p><pre><code>export default class OpDefaultIcon{     constructor(){    this.opIcon = new Array;    this.opIcon[&quot;add&quot;]=&lt;div id=&quot;add&quot; &gt;&lt;Icon key=&quot;add&quot; type=&quot;file-add&quot; className={styles.iconStyle}/&gt;添加&lt;/div&gt;;    this.opIcon[&quot;del&quot;]=&lt;div id=&quot;del&quot; &gt;&lt;Icon key=&quot;del&quot; type=&quot;delete&quot; className={styles.iconStyle}/&gt;删除&lt;/div&gt;;    this.opIcon[&quot;detail&quot;]=&lt;div id=&quot;detail&quot; &gt;&lt;Icon key=&quot;detail&quot; type=&quot;file-text&quot; className={styles.iconStyle}/&gt;详情&lt;/div&gt;;    this.opIcon[&quot;export&quot;]=&lt;div id=&quot;export&quot;  &gt;&lt;Icon key=&quot;export&quot; type=&quot;cloud-upload&quot; className={styles.iconStyle}/&gt;导出&lt;/div&gt;;    this.opIcon[&quot;import&quot;]=&lt;div id=&quot;import&quot; &gt;&lt;Icon key=&quot;import&quot; type=&quot;cloud-download-o&quot; className={styles.iconStyle}/&gt;导入&lt;/div&gt;;    this.opIcon[&quot;edit&quot;]=&lt;div id=&quot;edit&quot; &gt;&lt;Icon key=&quot;edit&quot; type=&quot;edit&quot; className={styles.iconStyle}/&gt;编辑&lt;/div&gt;;    this.opIcon[&quot;default&quot;]=&lt;div id=&quot;default&quot; &gt;&lt;Icon key=&quot;default&quot; type=&quot;cloud&quot; className={styles.iconStyle}/&gt;默认&lt;/div&gt;;}getDefaultIcon(name,alias,type,opClick){    let icon = this.opIcon[name]    if(!icon)icon=this.opIcon[&quot;default&quot;]    let element = icon;    if(alias){        if(type === 1){            return React.cloneElement(element,{onClick:opClick,key:name},element.props.children[0],alias);            }else{            return React.cloneElement(element,{onClick:opClick,key:name},element.props.children[0]);          }    }    return React.cloneElement(element,{onClick:opClick,key:name},element.props.children);  }  }</code></pre><p>调用起来也非常方便，模块也符合单一原则，低耦合原则。    </p><pre><code>const e = this.defaultIcon.getDefaultIcon(name,alias,type,opClick)</code></pre><p>结构很清晰，使用起来也很简单粗暴。    </p><p><strong>总结</strong>            </p><p>对于平常的一些模块的封装，需要深刻了解最终需要达到的效果，再来选择最适合的设计模式来解决问题。    </p><p>如果碰到一些事件，可以直接通过回调来处理，要保证模块的单一性，和低耦合。        </p><p>常用项目中的一些模块(地图，表格，模态框一类)可以通过常用的混合设计模式就可以达到理想的效果，结构清晰，可以复用。<br><strong>△ 不要为了用设计模式而用设计模式，工作项目需要、能更好解决问题而用</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;在框架中使用设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;现在的一些框架封装的都很好，我们可以通过框架暴露的一些API就可以解决一般的业务需求。但项目比较大，内部的模块复用较多，需要自己架构，模块达到复用的效果，使用设计模式就可以更好地解决问题
      
    
    </summary>
    
    
      <category term="JS" scheme="http://fishluo1992.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Vue的Toast</title>
    <link href="http://fishluo1992.github.io/2018/07/06/vue%E7%9A%84Toast%E5%B0%81%E8%A3%85/"/>
    <id>http://fishluo1992.github.io/2018/07/06/vue的Toast封装/</id>
    <published>2018-07-06T12:33:28.000Z</published>
    <updated>2018-07-30T12:33:49.290Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="JS" scheme="http://fishluo1992.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS的事件循环</title>
    <link href="http://fishluo1992.github.io/2018/06/13/%E6%B5%8F%E8%A7%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://fishluo1992.github.io/2018/06/13/浏览的事件循环/</id>
    <published>2018-06-12T16:00:00.000Z</published>
    <updated>2018-06-14T06:44:42.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器的多线程"><a href="#浏览器的多线程" class="headerlink" title="浏览器的多线程"></a>浏览器的多线程</h2><p>这里可能产生误区，浏览器不是单线程的吗？错了，JS是单线程的语言。浏览器需要渲染页面，执行JS等，是多线程的。<br><img src="../../../../img/bower.png" alt="vue_renderFn"> </p><h4 id="GUI线程"><a href="#GUI线程" class="headerlink" title="GUI线程"></a>GUI线程</h4><p>职责：负责浏览器的页面html、css的构建，DOM树、renderObject对象，会计算出每个html的布局和解析css样式，最终呈现我们所看到的页面。  </p><h4 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h4><p>职责：负责JS脚本的执行与GUI渲染线程是互斥的，这也是为啥html页面前引入JS会导致页面渲染速度变慢。所以一般把JS放在html页尾。当解析html时，如果页面有JS的引入，JS引擎会把JS全部执行一遍，执行完毕后，GUI线程才会继续执行。  </p><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p>职责： 事件触发时，负责把事件放入队列，等待特定的触发条件时再执行。  </p><h4 id="定时器线程"><a href="#定时器线程" class="headerlink" title="定时器线程"></a>定时器线程</h4><p>职责： 将setTimeout 和 setInteval执行函数在触发时放入队列等待执行。  </p><h4 id="http请求线程"><a href="#http请求线程" class="headerlink" title="http请求线程"></a>http请求线程</h4><p>职责: 监听请求状态变更，将相应函数放入队列，等待执行。</p><h2 id="JS事件循环"><a href="#JS事件循环" class="headerlink" title="JS事件循环"></a>JS事件循环</h2><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>JS引擎的运行机制分为：<strong>执行栈</strong>和<strong>队列</strong>， JS的代码都在栈中执行，分为<strong>同步执行</strong>和<strong>异步执行</strong>，只有同步代码执行完毕后，才会执行异步代码。 </p><p><strong>JS引擎解析代码规则：</strong><br>1.先把执行栈内的代码都执行一遍。<br>2.在执行的过程中，如果碰到触发事件(点击或者别的事件)、http请求(ajax请求)、延时执行(setTimeout，setInterval)就会依各自的线程进行监听，放入队列。<br>3.当执行栈空后，就会依次查找队列，把适时的代码放入执行栈，执行相应的代码。  </p><p>一道常见的Event Loop 面试题    </p><pre><code>console.log(&apos;script start&apos;);const date = new Date();setTimeout(() =&gt; {    console.log(&apos;setTimeout1&apos; + &apos;------&apos; + (new Date() - date));}, 0);setTimeout(() =&gt; {    console.log(&apos;setTimeout2&apos; + &apos;------&apos; + (new Date() - date));},0)new Promise((resolve) =&gt; {    console.log(&apos;script1&apos;);    resolve();}).then(function() {    console.log(&apos;script 2&apos;);}).then(function() {    console.log(&apos;script 3&apos;);})console.log(&apos;script end&apos;);    </code></pre><p>直接看答案吧     </p><pre><code>script start  script1  script end  script 2  script 3  setTimeout1------6 setTimeout2------8  // 这里可能每次的值都不一样  </code></pre><p>在解释结果前还需要了解一下。JS引擎在解析JS代码时，会把任务源分为：<strong>微任务</strong>和<strong>宏任务</strong>；微任务包括：promise的回调、Object.observe，宏任务有：JS、setTimeout、setIntterval;<br>JS的设计是单线程的，在执行任务时，会把JS从头到尾依次解析，当碰到微任务和宏任务时，会把他们放入队列，等待执行。JS还在执行，在执行完后，就会去队列先把微任务依次放入栈内执行。这就是第一次循环，当把第一次执行产生的微任务执行完毕后就会把队列的宏任务拿出放入执行栈，依次执行，执行完后再循环。这样的执行顺序就叫事件循环，也就是Event Loop;结合线程的理解会更容易也会更深刻，所以即使setTimeout的延时设置为0，但他属于宏任务，等JS和微任务都执行完毕后的下一个事件循环才会执行。</p><p>然后再看上面的那道题，会不会瞬间感觉清洗脱俗。现在再来解析下答案。<br>1.JS是单线程的（为了解决一些操作DOM会产生无法描述的顺序问题等），代码依次执行，所以第一个输出 script start;<br>2.解析碰到setTimeout，这个属于宏任务，放入队列，等待下一次循环再执行。<br>3.promise会先输出同步的 script1 ，then的回调是微任务，放入执行队列。<br>4.输出 script end ;<br>到了这里就已经清空了一次任务栈，然后开始查找微任务。<br>5.把微任务的任务放入执行栈执行，输出script2,再输出回调的script3。<br>6.队列的微任务已清空完毕，开始下一次事件循环，把队列的宏任务放入执行栈内执行，输出第一个setTimeout1,setTimeout源码规定了最小值为4ms，所以不论执行速度，执行的结果最短都大于4ms。再输出setTimeout2.<br>整个事件执行完毕。  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.结合浏览器的线程来理解会更明白一点。<br>2.JS的执行会被线程监听。如我们平常所用的观察者模式一样，每个被放入队列的事件都会被打上标记，比如ajax请求会被http线程监听，也就是当发起一个请求后，http属于pedding状态，当数据返回或者请求错误时，http线程会把结果返回，Event Loop当次循环到这个事件，放入栈内执行ajax回调，把结果返回。<br>3.如果需要更深层次的I/O事件，需要了解浏览器的JS引擎，先埋个点。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浏览器的多线程&quot;&gt;&lt;a href=&quot;#浏览器的多线程&quot; class=&quot;headerlink&quot; title=&quot;浏览器的多线程&quot;&gt;&lt;/a&gt;浏览器的多线程&lt;/h2&gt;&lt;p&gt;这里可能产生误区，浏览器不是单线程的吗？错了，JS是单线程的语言。浏览器需要渲染页面，执行JS等，是
      
    
    </summary>
    
    
      <category term="JS" scheme="http://fishluo1992.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Vue的render函数</title>
    <link href="http://fishluo1992.github.io/2018/06/06/vue%E7%9A%84render%E5%87%BD%E6%95%B0/"/>
    <id>http://fishluo1992.github.io/2018/06/06/vue的render函数/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-08-14T08:03:51.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>如果需要用vue来编写一些可复用的组件，那么就需要深入了解vue的render函数了。先了解下vue的渲染流程<br><img src="../../../../img/vue_rendertree.png" alt="vue_renderFn"><br>可以看出，模板通过编译生成AST，再由AST生成vue的render函数，render函数结合数据生成了Vitual DOM,再由vue的diff算法和patch函数生成AST树。<br><strong>AST</strong>：抽象语法树。<br><img src="../../../../img/ast.png" alt="ast"><br><strong>render函数</strong>：用来生成Vnode，vue是推荐使用模板来构建我们的应用界面，但底层还是会将模板编译成render函数。跑vue项目，在浏览器查看文件，我们可以看到模板编译成render的样子。   </p><pre><code>var render = function() {  var _vm = this  var _h = _vm.$createElement  var _c = _vm._self._c || _h  return _c(&quot;div&quot;, { staticClass: &quot;container&quot; }, [    _c(&quot;div&quot;, { staticClass: &quot;seach-conaitor&quot; }, [      _c(        &quot;div&quot;,        { staticClass: &quot;seach-box&quot;, staticStyle: { width: &quot;465px&quot; } },        [          _c(            &quot;button&quot;,            {              staticClass: &quot;change_btn_bgcolor&quot;,              on: { click: _vm.creatNewEvalution }            },            [_vm._v(&quot;流程&quot;)]          ),          _vm._v(&quot; &quot;),          _c(&quot;input&quot;, {            directives: [              {                name: &quot;model&quot;,                rawName: &quot;v-model&quot;,                value: _vm.searchText,                expression: &quot;searchText&quot;              }            ],            attrs: { type: &quot;text&quot;, placeholder: &quot;请输入关键字&quot; },            domProps: { value: _vm.searchText },            on: {              keyup: function($event) {                if (                  !(&quot;button&quot; in $event) &amp;&amp;                  _vm._k($event.keyCode, &quot;enter&quot;, 13, $event.key)                ) {                  return null                }                _vm.searchItem($event)              },</code></pre><p>上面被编译的就是我们的.vue文件，最终还是会被编译成这样的render函数。<br><strong>Virtual DOM</strong>:vue的虚拟Dom树。<br><strong>Diff</strong>:vue的diff算法，内部实现很复杂，普通的理解是计算改变的状态，只要父组件状态改变，所有的子组件都会被更新，再结合patch生成新的AST树。<br><strong>Patch</strong>:负责把这些虚拟DOM真正施加到真实的DOM上。  </p><h2 id="vue的渲染机制"><a href="#vue的渲染机制" class="headerlink" title="vue的渲染机制"></a>vue的渲染机制</h2><h3 id="vue的构建模式"><a href="#vue的构建模式" class="headerlink" title="vue的构建模式"></a>vue的构建模式</h3><p><strong>独立构建</strong> ：包含了模板编译器，渲染过程 HTML字符串-&gt;render()-&gt;VNode-&gt;真实的DOM节点。<br><strong>运行时构建</strong>：不包含模板编译器，渲染过程 render()-&gt;VNode-&gt;真实的DOM节点。<br>独立构建可以理解为  </p><p><img src="../../../../img/vue_render2.png" alt="vue_render"><br>再看下运行时构建  </p><p><img src="../../../../img/mount.png" alt="vue_render"><br>可以看出，在有三种渲染模式，分别是自定义的render()、template、el。<br><strong>el的写法</strong>    </p><pre><code>let app = new Vue({    el:&apos;#app&apos;,    data(){        return{             msg:&apos;hello world&apos;        }    }})  </code></pre><p>这个就是我们通常直接html内的写法，直接挂载到页面元素上。等级最低，如果有template或者render，el将被忽略。  </p><p><strong>template的写法</strong>    </p><pre><code>let app = new Vue({    template:&apos;&lt;div&gt;{{msg}}&lt;/div&gt;&apos;,    data() {        return {            msg: &apos;hello world&apos;        }    }})</code></pre><p>指一个字符串模板作为vue实例的标识使用。模板将会替换挂载的元素。如果render函数存在，该模板将会被忽略。  </p><p><strong>自定义render函数</strong>    </p><pre><code>Vue.component(&apos;anchored-heading&apos;,{    render:function(createElement){        return createElement(            &apos;h&apos; + this.level,               this.$slots.default        )    },    props:{        level:{            type:Number,            required:true        }    }})</code></pre><p>字符串模板的代替方案，允许你发挥JS最大的编程能力。该渲染函数接收一个<em>CreateElement</em>方法作为第一个参数用来创建VNode。<br>vue选项中的render函数诺存在，则vue构造函数不会从template选项或通过el选项指定的挂载元素中提取的HTML模板编译渲染函数。<br>其实这三种渲染模式最终都会得到render函数，只不过用户自定义的render函数省去了程序分析的过程，等同于处理过的render函数，而普通的template或者el只是字符，还需要解析成AST，再将AST转化成render函数。<br>官方推荐还是使用template或者el。这两种属于声明式渲染，理解容易。但对于一些逻辑复杂的需求，render用起来更方便。现在很多vue的UI插件是用render函数编写。<br><strong>CreateElement</strong><br>Vue通过建立一个虚拟DOM对真实DOM发生的变化保持追踪。    </p><pre><code>return createElement(&apos;h1&apos;,this.blogtitle)  </code></pre><p>createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为“虚拟节点 (Virtual Node)”，也常简写它为“VNode”。“虚拟 DOM”是对由 Vue 组件树建立起来的整个 VNode 树的称呼。<br><em>createElement参数</em>    </p><pre><code>// @returns {VNode}createElement(  // {String | Object | Function}  // 一个 HTML 标签字符串，组件选项对象，或者  // 解析上述任何一种的一个 async 异步函数，必要参数。  &apos;div&apos;,  // 如果是函数需要返回一个Object或者String  // {Object}  // 一个包含模板相关属性的数据对象  // 这样，您可以在 template 中使用这些属性。可选参数。  {    // data  },  // {String | Array}  // 子节点 (VNodes)，由 `createElement()` 构建而成，  // 或使用字符串来生成“文本节点”。可选参数。  [    &apos;先写一些文字&apos;,    createElement(&apos;h1&apos;, &apos;一则头条&apos;),    createElement(MyComponent, {      props: {        someProp: &apos;foobar&apos;      }    })  ])</code></pre><p>再看第二个参数，data    </p><pre><code>{  // 和`v-bind:class`一样的 API  // 接收一个字符串、对象或字符串和对象组成的数组  &apos;class&apos;: {    foo: true,    bar: false  },  // 和`v-bind:style`一样的 API  // 接收一个字符串、对象或对象组成的数组  style: {    color: &apos;red&apos;,    fontSize: &apos;14px&apos;  },  // 正常的 HTML 特性  attrs: {    id: &apos;foo&apos;  },  // 组件 props  props: {    myProp: &apos;bar&apos;  },  // DOM 属性  domProps: {    innerHTML: &apos;baz&apos;  },  // 事件监听器基于 `on`  // 所以不再支持如 `v-on:keyup.enter` 修饰器  // 需要手动匹配 keyCode。  on: {    click: this.clickHandler  },  // 仅对于组件，用于监听原生事件，而不是组件内部使用  // `vm.$emit` 触发的事件。  nativeOn: {    click: this.nativeClickHandler  },  // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`  // 赋值，因为 Vue 已经自动为你进行了同步。  directives: [    {      name: &apos;my-custom-directive&apos;,      value: &apos;2&apos;,      expression: &apos;1 + 1&apos;,      arg: &apos;foo&apos;,      modifiers: {        bar: true      }    }  ],  // 作用域插槽格式  // { name: props =&gt; VNode | Array&lt;VNode&gt; }  scopedSlots: {    default: props =&gt; createElement(&apos;span&apos;, props.text)  },  // 如果组件是其他组件的子组件，需为插槽指定名称  slot: &apos;name-of-slot&apos;,  // 其他特殊顶层属性  key: &apos;myKey&apos;,  ref: &apos;myRef&apos;}</code></pre><p>这个官方的表述已经很清楚了。如果使用render函数来渲染，v-model，v-if这样的指令都需要自己定义。可以在render函数中封装一些自己业务需要的指令。<br>比较一下<code>template</code>和<code>render</code>创建一个相同的组件    </p><pre><code>&lt;div id=&quot;app&quot;&gt;     &lt;custom-element&gt;&lt;/custom-element&gt; &lt;/div&gt; Vue.component(&apos;custom-element&apos;,     { template: `&lt;div id=&quot;box&quot; :class=&quot;{show: show}&quot;@click=&quot;handleClick&quot;&gt;Hello Vue!&lt;/div&gt;`,    data () {       return {             show: true       }     },     methods: {         handleClick: function () {                 console.log(&apos;Click!&apos;)             }     } })</code></pre><p><code>render</code>    </p><pre><code>Vue.component(&apos;custom-element&apos;, {    render: function(createElement) {        return createElement(&apos;div&apos;, {            class: {                show: this.show            },            attrs: {                id: &apos;box&apos;            },            on: {                click: this.handleClick            }        }, &apos;Hello Vue!&apos;)    },    data() {        return {            show: true        }    },    methods: {        handleClick: function() {            console.log(&apos;Click!&apos;)        }    }})</code></pre><p>再声明一个Vue实例，并挂载到真实DOM上    </p><pre><code>let app = new Vue({    el: &apos;#app&apos;})  </code></pre><p>这样就很好理解了，render函数不需要编译生成AST。<br>render函数结合上面我们给的数据直接生成vitual DOM,再由vue的diff和patch映射到真实DOM上，更新视图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;如果需要用vue来编写一些可复用的组件，那么就需要深入了解vue的render函数了。先了解下vue的渲染流程&lt;br&gt;&lt;im
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://fishluo1992.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue的MVVM</title>
    <link href="http://fishluo1992.github.io/2018/06/01/vue%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://fishluo1992.github.io/2018/06/01/vue的理解/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2018-06-05T03:13:29.079Z</updated>
    
    <content type="html"><![CDATA[<p>人生时苦，所以要做一个简单的人，<br>常想一二，不思八九，<br>越活越带感。  </p><h2 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h2><p>用过vue写过项目或者看过vue的同学在被问到“vue的响应式原理时”可能都会直接说：  Vue 是通过Object.defineProperty方法把data对象的全部属性转化成getter/setter，当属性被访问或者被修改时通知变化。  </p><p>Object.defineProperty的API的定义？这个就是ES5改变属性的值的一个API！这么回答肯定是有问题的，MDN的定义是：<br><em>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</em><br>再看vue官网介绍的响应式原理图。<br><img src="../../../../img/vue_prototype.jpg" alt="vue"><br> 首先通过渲染触发了Data的getter进行依赖收集，源码里有个一Deps订阅者，在数据变化时会通知所有的Watcher观察者，也就是说，在data变化时会触发它的setter，setter通知Watcher，Watcher通知组件执行Render Function，函数内再根据diff算法来实现视图的更新（render函数会根据内部的VNode，也就是vue的虚拟DOM生成DOM树，diff就是新VNode节点与旧VNode节点进行深度对比(vue源码是比较新旧两个列表的vm的数据状态)，算出施加到真实DOM上最小的改动，然后更新视图）。  </p><h2 id="vue的MVVM实现"><a href="#vue的MVVM实现" class="headerlink" title="vue的MVVM实现"></a>vue的MVVM实现</h2><p>再分析vue的MVVM的实现  </p><p><img src="../../../../img/vue_mvvm.png" alt="vue_mvvm"><br>      new MVVM()也就是构造函数Vue的实例 new Vue()，是Vue的入口函数。<br>      Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可以通知订阅者。<br>      Watcher 订阅者，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。<br>      Compile 指令解析器，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据和绑定相应的更新数据。<br>      Dep 消息订阅器，Observer内部维护的一个数组，用来收集订阅者Wacher，数据变动触发notify函数，再调用订阅者的update方法。  </p><h3 id="new-MVVM"><a href="#new-MVVM" class="headerlink" title="new MVVM()"></a>new MVVM()</h3><p>先看vue的<a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L107" target="_blank" rel="noopener">initData</a> 这个就是new Vue内初始化的数据，内部将数据进行Observer监听数据变化。    </p><pre><code>/*初始化data*/function initData (vm: Component) {  /*得到data数据*/  let data = vm.$options.data  data = vm._data = typeof data === &apos;function&apos;    ? getData(data, vm)    : data || {}  /*对对象类型进行严格检查，只有当对象是纯javascript对象的时候返回true*/  if (!isPlainObject(data)) {data = {}process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(  &apos;data functions should return an object:\n&apos; +  &apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;,  vm)}  // proxy data on instance  /*遍历data对象*/  const keys = Object.keys(data)  const props = vm.$options.props  let i = keys.length  //遍历data中的数据  while (i--) {/*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/if (props &amp;&amp; hasOwn(props, keys[i])) {  process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(    `The data property &quot;${keys[i]}&quot; is already declared as a prop. ` +    `Use prop default value instead.`,    vm  )} else if (!isReserved(keys[i])) {  /*判断是否是保留字段*/  /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/  proxy(vm, `_data`, keys[i])}      }      // observe data      /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/      observe(data, true /* asRootData */)    }    function getData (data: Function, vm: Component): any {      try {        return data.call(vm)      } catch (e) {        handleError(e, vm, `data()`)        return {}      }    }    </code></pre><p>内部的实现还是很复杂的，再说说proxy函数。     </p><pre><code>export function proxy (target: Object, sourceKey: string, key: string) {  sharedPropertyDefinition.get = function proxyGetter () {    return this[sourceKey][key]  }  sharedPropertyDefinition.set = function proxySetter (val) {    this[sourceKey][key] = val  }  Object.defineProperty(target, key, sharedPropertyDefinition)}</code></pre><p>代理函数，实现数据代理，<code>vm.options -&gt; vm._data.options</code>，可以理解为;     </p><pre><code>proxy: function(key, setter, getter) {    var me = this;    setter = setter ||     Object.defineProperty(_vm, key, {        configurable: false, //不能再define定义        enumerable: true,        get: function proxyGetter() {            return _vm._data[key];        },        set: function proxySetter(newVal) {            _vm._data[key] = newVal;        }    });},</code></pre><h3 id="Observer监听者"><a href="#Observer监听者" class="headerlink" title="Observer监听者"></a>Observer监听者</h3><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L34" target="_blank" rel="noopener">Oberver</a>的作用就是遍历对象的属性进行双向绑定。    </p><pre><code>export class Observer {  value: any;  dep: Dep;  vmCount: number; // number of vms that has this object as root $data  constructor (value: any) {    this.value = value    this.dep = new Dep()    this.vmCount = 0    /*    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16    */    def(value, &apos;__ob__&apos;, this)    if (Array.isArray(value)) {      /*          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。      */      const augment = hasProto        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/      augment(value, arrayMethods, arrayKeys)      /*Github:https://github.com/answershuto*/      /*如果是数组则需要遍历数组的每一个成员进行observe*/      this.observeArray(value)    } else {      /*如果是对象则直接walk进行绑定*/      this.walk(value)    }  }  /**   * Walk through each property and convert them into   * getter/setters. This method should only be called when   * value type is Object.   */  walk (obj: Object) {    const keys = Object.keys(obj)    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/    for (let i = 0; i &lt; keys.length; i++) {      defineReactive(obj, keys[i], obj[keys[i]])    }  }  /**   * Observe a list of Array items.   */  observeArray (items: Array&lt;any&gt;) {    /*数组需要便利每一个成员进行observe*/    for (let i = 0, l = items.length; i &lt; l; i++) {      observe(items[i])    }  }}</code></pre><p>defineReactive作用是通过defineProperty给数据定义getter\setter，当数据变动时通知Deps订阅器，映射给Watcher观察者对视图做变更。</p><pre><code>Object.defineProperty(obj, key, {    enumerable: true,    configurable: true,    get: function reactiveGetter () {      const value = getter ? getter.call(obj) : val      if (Dep.target) {        dep.depend()        if (childOb) {          childOb.dep.depend()          if (Array.isArray(value)) {            dependArray(value)          }        }      }      return value    },    set: function reactiveSetter (newVal) {      const value = getter ? getter.call(obj) : val      /* eslint-disable no-self-compare */      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {        return      }      /* eslint-enable no-self-compare */      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) {        customSetter()      }      if (setter) {        setter.call(obj, newVal)      } else {        val = newVal      }        // 如果是新值并且是object的话就进行监听      childOb = !shallow &amp;&amp; observe(newVal)      dep.notify() // 通知订阅者    }  })  </code></pre><h3 id="Deps订阅器"><a href="#Deps订阅器" class="headerlink" title="Deps订阅器"></a>Deps订阅器</h3><p>Deps订阅器的实现可以简单这样理解，就是数组subs  ，可以订阅多个观察者，依赖收集后Deps也会存在多个Watcher对象，在数据变更时通知所有的Watcher。</p><pre><code>var uid = 0;function Dep() {    this.id = uid++;    this.subs = []; // 这个就是订阅器}Dep.prototype = {    addSub: function(sub) {        this.subs.push(sub);    },    depend: function() {        Dep.target.addDep(this);    },    removeSub: function(sub) {        var index = this.subs.indexOf(sub);        if (index != -1) {            this.subs.splice(index, 1);        }    },    notify: function() {        this.subs.forEach(function(sub) {            sub.update();  // 视图局部更新 subs[index]        });    }};</code></pre><h3 id="Watcher-观察者"><a href="#Watcher-观察者" class="headerlink" title="Watcher 观察者"></a>Watcher 观察者</h3><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js#L24" target="_blank" rel="noopener">Watcher</a>就是一个观察对象，依赖收集以后Watcher对象会被保存在Deps中。    </p><pre><code>export default class Watcher {  vm: Component;  expression: string;  cb: Function;  id: number;  deep: boolean;  user: boolean;  lazy: boolean;  sync: boolean;  dirty: boolean;  active: boolean;  deps: Array&lt;Dep&gt;;  newDeps: Array&lt;Dep&gt;;  depIds: ISet;  newDepIds: ISet;  getter: Function;  value: any;  constructor (    vm: Component,    expOrFn: string | Function,    cb: Function,    options?: Object  ) {    this.vm = vm    /*_watchers存放订阅者实例*/    vm._watchers.push(this)    // options    if (options) {      this.deep = !!options.deep      this.user = !!options.user      this.lazy = !!options.lazy      this.sync = !!options.sync    } else {      this.deep = this.user = this.lazy = this.sync = false    }    this.cb = cb    this.id = ++uid // uid for batching    this.active = true    this.dirty = this.lazy // for lazy watchers    this.deps = []    this.newDeps = []    this.depIds = new Set()    this.newDepIds = new Set()    this.expression = process.env.NODE_ENV !== &apos;production&apos;      ? expOrFn.toString()      : &apos;&apos;    // parse expression for getter    /*把表达式expOrFn解析成getter*/    if (typeof expOrFn === &apos;function&apos;) {      this.getter = expOrFn    } else {      this.getter = parsePath(expOrFn)      if (!this.getter) {        this.getter = function () {}        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(          `Failed watching path: &quot;${expOrFn}&quot; ` +          &apos;Watcher only accepts simple dot-delimited paths. &apos; +          &apos;For full control, use a function instead.&apos;,          vm        )      }    }    this.value = this.lazy      ? undefined      : this.get()  }  /**   * Evaluate the getter, and re-collect dependencies.   */   /*获得getter的值并且重新进行依赖收集*/  get () {    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/    pushTarget(this)    let value    const vm = this.vm    /*      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。      在将Dep.target设置为自生观察者实例以后，执行getter操作。      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，      那么在执行getter的时候就会触发a跟c两个数据的getter函数，      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，      将该观察者对象放入闭包中的Dep的subs中去。    */    if (this.user) {      try {        value = this.getter.call(vm, vm)      } catch (e) {        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)      }    } else {      value = this.getter.call(vm, vm)    }    // &quot;touch&quot; every property so they are all tracked as    // dependencies for deep watching    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/    if (this.deep) {      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/      traverse(value)    }    /*将观察者实例从target栈中取出并设置给Dep.target*/    popTarget()    this.cleanupDeps()    return value  }  /**   * Add a dependency to this directive.   */   /*添加一个依赖关系到Deps集合中*/  addDep (dep: Dep) {    const id = dep.id    if (!this.newDepIds.has(id)) {      this.newDepIds.add(id)      this.newDeps.push(dep)      if (!this.depIds.has(id)) {        dep.addSub(this)      }    }  }  /**   * Clean up for dependency collection.   */   /*清理依赖收集*/  cleanupDeps () {    /*移除所有观察者对象*/    let i = this.deps.length    while (i--) {      const dep = this.deps[i]      if (!this.newDepIds.has(dep.id)) {        dep.removeSub(this)      }    }    let tmp = this.depIds    this.depIds = this.newDepIds    this.newDepIds = tmp    this.newDepIds.clear()    tmp = this.deps    this.deps = this.newDeps    this.newDeps = tmp    this.newDeps.length = 0  }  /**   * Subscriber interface.   * Will be called when a dependency changes.   */   /*      调度者接口，当依赖发生改变的时候进行回调。   */  update () {    /* istanbul ignore else */     // 1. 每次调用run()的时候会触发相应属性的getter    // getter里面会触发dep.depend()，继而触发这里的addDep    // 2. 假如相应属性的dep.id已经在当前watcher的depIds里，说明不是一个新的属性，仅仅是改变了其值而已    // 则不需要将当前watcher添加到该属性的dep里    // 3. 假如相应属性是新的属性，则将当前watcher添加到新属性的dep里    // 如通过 vm.child = {name: &apos;a&apos;} 改变了 child.name 的值，child.name 就是个新属性    // 则需要将当前watcher(child.name)加入到新的 child.name 的dep里    // 因为此时 child.name 是个新值，之前的 setter、dep 都已经失效，如果不把 watcher 加入到新的 child.name 的dep中    // 通过 child.name = xxx 赋值的时候，对应的 watcher 就收不到通知，等于失效了    // 4. 每个子属性的watcher在添加到子属性的dep的同时，也会添加到父属性的dep    // 监听子属性的同时监听父属性的变更，这样，父属性改变时，子属性的watcher也能收到通知进行update    // 这一步是在 this.get() --&gt; this.getVMVal() 里面完成，forEach时会从父级开始取值，间接调用了它的getter    // 触发了addDep(), 在整个forEach过程，当前wacher都会加入到每个父级过程属性的dep    // 例如：当前watcher的是&apos;child.child.name&apos;, 那么child, child.child, child.child.name这三个属性的dep都会加入当前watcher    if (this.lazy) {      this.dirty = true    } else if (this.sync) {      /*同步则执行run直接渲染视图*/      this.run()    } else {      /*异步推送到观察者队列中，由调度者调用。*/      queueWatcher(this)    }  }  /**   * Scheduler job interface.   * Will be called by the scheduler.   */   /*      调度者工作接口，将被调度者回调。    */  run () {    if (this.active) {      const value = this.get()      if (        value !== this.value ||        // Deep watchers and watchers on Object/Arrays should fire even        // when the value is the same, because the value may        // have mutated.        /*            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。        */        isObject(value) ||        this.deep      ) {        // set new value        const oldValue = this.value        /*设置新的值*/        this.value = value        /*触发回调渲染视图*/        if (this.user) {          try {            this.cb.call(this.vm, value, oldValue)          } catch (e) {            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)          }        } else {          this.cb.call(this.vm, value, oldValue)        }      }    }  }  /**   * Evaluate the value of the watcher.   * This only gets called for lazy watchers.   */   /*获取观察者的值*/  evaluate () {    this.value = this.get()    this.dirty = false  }  /**   * Depend on all deps collected by this watcher.   */   /*收集该watcher的所有deps依赖*/  depend () {    let i = this.deps.length    while (i--) {      this.deps[i].depend()    }  }  /**   * Remove self from all dependencies&apos; subscriber list.   */   /*将自身从所有依赖收集订阅列表删除*/  teardown () {    if (this.active) {      // remove self from vm&apos;s watcher list      // this is a somewhat expensive operation so we skip it      // if the vm is being destroyed.      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/      if (!this.vm._isBeingDestroyed) {        remove(this.vm._watchers, this)      }      let i = this.deps.length      while (i--) {        this.deps[i].removeSub(this)      }      this.active = false    }  }}</code></pre><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p><a href="https://github.com/vuejs/vue/blob/dev/src/compiler/parser/index.js" target="_blank" rel="noopener">Compile</a>也就是指令解析器，这个和一般的模板引擎的区别都不大，大部分通过正则判断内部指令（普通指令和事件指令）。这个就简单说道这里。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要学到精髓还得多看看源码，看完也可以学到很多。整体架构，逻辑API的依赖等还需要仔细理解学习。<br>多看源码就对了。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人生时苦，所以要做一个简单的人，&lt;br&gt;常想一二，不思八九，&lt;br&gt;越活越带感。  &lt;/p&gt;
&lt;h2 id=&quot;vue响应式原理&quot;&gt;&lt;a href=&quot;#vue响应式原理&quot; class=&quot;headerlink&quot; title=&quot;vue响应式原理&quot;&gt;&lt;/a&gt;vue响应式原理&lt;/h2
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://fishluo1992.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>奇怪的流程</title>
    <link href="http://fishluo1992.github.io/2018/05/31/vue%E7%9A%84%E5%B0%8F%E5%9D%91one/"/>
    <id>http://fishluo1992.github.io/2018/05/31/vue的小坑one/</id>
    <published>2018-05-31T11:47:45.000Z</published>
    <updated>2018-06-01T09:33:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p>  这是上一个项目了，公司内部的OA系统，页面近30个了，由我这个前端和一个java大神完成。总体时间也近两个月，接口的调试时间也占了很多，因为数据逻辑的耦合度太高了。<br>  下面谈谈一其中的个小需求吧！看图！  </p><p>  <img src="../../../../img/project_1.png" alt="js原型链"><br>  就是这种审批流程图，看起来比一般的线流程图多了一点样式。因为项目的模块不少，每个模块都有不同的审批流程，像这样  </p><p>   <img src="../../../../img/project_2.png" alt="js原型链">  </p><h2 id="解剖一下"><a href="#解剖一下" class="headerlink" title="解剖一下"></a>解剖一下</h2><p>   每个模块多个流程都需要看到这个流程走向，图像的上面是一个显示详细审批的信息列表。因为每个模块的流程图都不同，所有只能每个模块封装一个独有的组件来分别显示。 数据直接父组件传给子组件。 </p><p> <em>思考</em><br>  看到这样的设计图，直接简单粗暴的分析下。<br>  流程的显示有三种，分别是未开始、已处理和下一步处理，另外还有个驳回箭头。<br>  1.一般来讲，我们首先想到的会是用canvas来控制几种样式的逻辑<br>  2.另外还可以用JS+CSS来控制。  </p><p>   <em>动手</em><br> 嗯，canvas貌似也不错，在花了一个多小时画完这个图后，瞅瞅代码，这什么鬼。代码上百行，还没加逻辑判断，连自己看不下去了。再试试下个方案吧。<br> vue,可以类似JSP页面，HTML可以嵌套JS。那么逻辑控制显示就没问题了。那就得先把图画好了，圆和条子很简单，箭头也直接border画个三角形就OK了，不正规的菱形？两个三角形对立就OK了。  </p><pre><code>border-top: 5px solid transparent;border-bottom: 5px solid transparent;border-left: 5px solid #878787;  </code></pre><p>对的，就是这样。  </p><p><em>逻辑和数据处理</em><br>UI界面的图就这样完美出来了，是不难吧。嗯，只是开始。后台给我的接口只有一个数据seq来控制整个流程。对的，只有一个seq！！！ 我这边需要控制每个步骤图的三种不同的显示和驳回箭头的显示。   </p><p>嗯，不难，真的。只是多了点判断，像这样。  </p><pre><code> if(res.data.data.length &gt; 1 &amp;&amp; index == res.data.data.length-1){    if(arr[index].seq &lt; arr[index-1].seq){        if(arr[index-1].seq == 2){            that.ctrl = {&quot;step&quot;:Number(item.seq)-1,&quot;stop&quot;:1}        }else if(arr[index-1].seq == 5){            that.ctrl = {&quot;step&quot;:Number(item.seq)-1,&quot;stop&quot;:2}        }else if(arr[index-1].seq == 6){            that.ctrl = {&quot;step&quot;:Number(item.seq)-1,&quot;stop&quot;:3}        }else{            that.ctrl = {&quot;step&quot;:8,&quot;stop&quot;:0}        }                }else{        that.ctrl = {&quot;step&quot;:Number(item.seq),&quot;stop&quot;:0}    }    }else{    that.ctrl = {&quot;step&quot;:1,&quot;stop&quot;:0}}</code></pre><p>最终直接把ctrl传给子组件，参数是step和驳回的stop。那么接下来就是子组件控制流程的样式了，对的，这个也不难。<br>先取到数据  </p><pre><code>watch:{     ctrl:function(newval,oldval){             if(newval != oldval){                 this.getData()             }         } }, props:{     ctrl:{         type:Object,         default:function(){             return {};         }     } }</code></pre><p>因为一个模块内的每个流程都需要这个显示，所有需要watch一下保证数据完美的显示。  </p><h2 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h2><p>数据有了，基本页面也完美展示了，那通过数据该咋渲染呢？<br>嗯，这个也不难。用来控制Class来控制就好，像这样  </p><pre><code>:class=&quot;step_t?&apos;ctrl-step-rebut&apos;:&apos;&apos;&quot;   </code></pre><p>是的这样可以控制两种，那这里有三种咋控制呢？这样？  </p><pre><code>:class=&quot;stepTwo?&apos;ctrl-first-right-writhe&apos;:(stepOne?&apos;ctrl-first-right-son&apos;:&apos;&apos;)&quot;  </code></pre><p>对的，就是这样，理论上三元表达式可以无限叠，但一般不会这样，万一其他人来维护这个项目呢，那不直接带刀找你了，所有两层就可以了，多层用if elseif来判断。<br>这样就可以完美的控制三种显示了。step 和 stop 也需要处理  </p><pre><code>switch (this.ctrl.step)           {               case 1:                 ...                break;                case 2:                ...                break;                 case 3:                ...                break;            }    switch (this.ctrl.stop){...}  </code></pre><p> 就这样，直接判断出流程走到哪一步，直接再通过显示哪里class来显示对应的样式就可以了。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.相比canvas来讲，用JS+css来解决这样流图更好，代码没那么复杂，能一看就懂，样式和一些逻辑也可以复用，清晰易懂。<br>2.业务都不难，难的是对底层代码的理解和自己实现业务逻辑的方法。每次碰到带点逻辑的业务还是需要仔细分析，保证自己能做到自己能做到的极限。<br>3.vue用起来还是很爽的，下一篇博客也来讲讲自己对vue的理解吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h4&gt;&lt;p&gt;  这是上一个项目了，公司内部的OA系统，页面近30个了，由我这个前端和一个java大神完成。总体时间也近两个月，接口的调试时间也占了很多，
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://fishluo1992.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>原型链的继承</title>
    <link href="http://fishluo1992.github.io/2018/05/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://fishluo1992.github.io/2018/05/28/原型链/</id>
    <published>2018-05-28T10:33:28.000Z</published>
    <updated>2018-09-19T10:24:51.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型链图-先上图"><a href="#原型链图-先上图" class="headerlink" title="原型链图(先上图)"></a>原型链图(先上图)</h2><p><img src="../../../../img/prototype_img.png" alt="js原型链">  </p><p>图片网上找的…</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="原型链的继承"><a href="#原型链的继承" class="headerlink" title="原型链的继承"></a>原型链的继承</h3><p>大家都知道面向对象有三大基本特性 ：封装、继承、多态。<br>继承是指让某个类型的对象获得另一个类型的对象的属性和方法。<br>而原型和原型链是Javascript实现继承的一种模型。<br>原型链的基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。<br>Javascript在创建对象的时候，都有一个叫做<strong>proto</strong>的内置属性，用于指向创建它的构造函数的原型对象，也就是图片上的prototype（这个属性指向原型对象，只有函数才有）。<br>每个对象都有<code>__proto__</code>属性，指向所继承的上层对象，最顶级是null;<br>从图上看，可以看到null的上一个指针是指向Object.prototype,也就是说,可以把Object看做是一个构造函数(其实它就是一个内置的构造函数)，其他的方法就是基于这个类型继承而来的。<br><code>var a = [];//这个同等于 var a = new Array();        var b = {}; // 同等于 var b = new Object();        console.log(a.__proto__ === Array.prototype) // true        console.log(b.__proto__ === Object.prototype) // true</code><br>我们发现a和b都有<code>__proto__</code>，分别指向了Array.prototype和Object.prototype。其实a,b都是内置的构造函数的实例对象，都基于类型分别继承了构造函数的prtotype。 </p><p>平常写的时候感觉很正常，其实像Array、Object这样的函数内置对象还有 Date、Function、RegExp、Json、Math。 </p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>只要创建一个新函数，就会根据规则给这个函数创建一个prototype属性，这个属性指向函数的原型对象。<br>也可以这样理解，所有函数对象都指向Function.prototype，都是Function的实例。<br><code>function Fn(){}  console.log(Fn.__proto__ === Function.prototype) //true</code><br>也就是说，<code>__proto__</code>存在于实例与构造函数原型对象之间，而不是存在于实例与构造函数之间。也可以理解为原型链的形成主要还是看<code>__proto__</code>，而不是prototype。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型链图-先上图&quot;&gt;&lt;a href=&quot;#原型链图-先上图&quot; class=&quot;headerlink&quot; title=&quot;原型链图(先上图)&quot;&gt;&lt;/a&gt;原型链图(先上图)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../../../../img/prototype_img.png&quot;
      
    
    </summary>
    
    
      <category term="JS" scheme="http://fishluo1992.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
