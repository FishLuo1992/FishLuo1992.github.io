<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fish_need_sea</title>
  <icon>https://www.gravatar.com/avatar/abda6d8c22ea7f0b52720e09ea7f58e3</icon>
  <subtitle>no one</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fishluo1992.github.io/"/>
  <updated>2018-05-29T02:57:38.003Z</updated>
  <id>http://fishluo1992.github.io/</id>
  
  <author>
    <name>没尾巴的鱼</name>
    <email>18720090169@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS原型的归纳与理解</title>
    <link href="http://fishluo1992.github.io/2018/05/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://fishluo1992.github.io/2018/05/28/原型链/</id>
    <published>2018-05-28T10:33:28.000Z</published>
    <updated>2018-05-29T02:57:38.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型链图-先上图"><a href="#原型链图-先上图" class="headerlink" title="原型链图(先上图)"></a>原型链图(先上图)</h2><p><img src="../../../../img/prototype_img.png" alt="js原型链">  </p><p>图片网上找的…</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="原型链的继承"><a href="#原型链的继承" class="headerlink" title="原型链的继承"></a>原型链的继承</h3><p>大家都知道面向对象有三大基本特性 ：封装、继承、多态。<br>继承是指让某个类型的对象获得另一个类型的对象的属性和方法。<br>而原型和原型链是Javascript实现继承的一种模型。<br>原型链的基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。<br>Javascript在创建对象的时候，都有一个叫做<strong>proto</strong>的内置属性，用于指向创建它的构造函数的原型对象，也就是图片上的prototype（这个属性指向原型对象，只有函数才有）。<br>每个对象都有<code>__proto__</code>属性，指向所继承的上层对象，最顶级是null;<br>从图上看，可以看到null的上一个指针是指向Object.prototype,也就是说,可以把Object看做是一个构造函数(其实它就是一个内置的构造函数)，其他的方法就是基于这个类型继承而来的。<br><code>var a = [];//这个同等于 var a = new Array();        var b = {}; // 同等于 var b = new Object();        console.log(a.__proto__ === Array.prototype) // true        console.log(b.__proto__ === Object.prototype) // true</code><br>我们发现a和b都有<code>__proto__</code>，分别指向了Array.prototype和Object.prototype。其实a,b都是内置的构造函数的实例对象，都基于类型分别继承了构造函数的prtotype。 </p><p>平常写的时候感觉很正常，其实像Array、Object这样的函数内置对象还有 Date、Function、RegExp、Json、Math。 </p><p>##构造函数  </p><p>只要创建一个新函数，就会根据规则给这个函数创建一个prototype属性，这个属性指向函数的原型对象。<br>也可以这样理解，所有函数对象都指向Function.prototype，都是Function的实例。<br><code>function Fn(){}  console.log(Fn.__proto__ === Function.prototype) //true</code><br>也就是说，<code>__proto__</code>存在于实例与构造函数原型对象之间，而不是存在于实例与构造函数之间。也可以理解为原型链的形成主要还是看<code>__proto__</code>，而不是prototype。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型链图-先上图&quot;&gt;&lt;a href=&quot;#原型链图-先上图&quot; class=&quot;headerlink&quot; title=&quot;原型链图(先上图)&quot;&gt;&lt;/a&gt;原型链图(先上图)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../../../../img/prototype_img.png&quot;
      
    
    </summary>
    
    
      <category term="JS" scheme="http://fishluo1992.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>think</title>
    <link href="http://fishluo1992.github.io/2018/05/22/%E9%B1%BC%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://fishluo1992.github.io/2018/05/22/鱼的世界/</id>
    <published>2018-05-22T06:53:28.000Z</published>
    <updated>2018-05-23T01:10:46.117Z</updated>
    
    <content type="html"><![CDATA[<pre><code>天空没有翅膀的痕迹，但我已飞过。  学习终究是自己的事，不需要他人来监控，真的没必要。  目前对于自己的计划已经脱落了一大截，需要再次静下心来，进入深层次的思考，对自己更深层次的鞭策。  多想想为什么，多思考人生。毕竟人生苦短，多思考，避免在短暂的人生走更大的弯路。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;天空没有翅膀的痕迹，但我已飞过。  
学习终究是自己的事，不需要他人来监控，真的没必要。  
目前对于自己的计划已经脱落了一大截，需要再次静下心来，进入深层次的思考，对自己更深层次的鞭策。  
多想想为什么，多思考人生。毕竟人生苦短，多思考，避免在短暂的人生
      
    
    </summary>
    
    
      <category term="Thinking" scheme="http://fishluo1992.github.io/tags/Thinking/"/>
    
  </entry>
  
</feed>
