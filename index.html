<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/images/favicon_32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/3.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="World, Sea" />





  <link rel="alternate" href="/atom.xml" title="fish_need_sea" type="application/atom+xml" />






<meta name="description" content="Living Thinking Programming">
<meta property="og:type" content="website">
<meta property="og:title" content="fish_need_sea">
<meta property="og:url" content="http://fishluo1992.github.io/index.html">
<meta property="og:site_name" content="fish_need_sea">
<meta property="og:description" content="Living Thinking Programming">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fish_need_sea">
<meta name="twitter:description" content="Living Thinking Programming">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://fishluo1992.github.io/"/>





  <title>fish_need_sea</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fish_need_sea</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">no one</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fishluo1992.github.io/2018/06/06/vue的render函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="没尾巴的鱼">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/img_1.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fish_need_sea">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/vue的render函数/" itemprop="url">Vue的render函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T00:00:00+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>如果需要用vue来编写一些可复用的组件，那么就需要深入了解vue的render函数了。先了解下vue的渲染流程<br><img src="../../../../img/ast.png" alt="ast"><br>可以看出，模板通过编译生成AST，再由AST生成vue的render函数，render函数结合数据生成了Vitual DOM(可以看我的上一篇文章<img src="https://fishluo1992.github.io/2018/06/01/vue%E7%9A%84%E7%90%86%E8%A7%A3/" alt="vue的理解">)，再由vue的diff和patch后更新视图。<br><strong>AST</strong>：抽象语法树。<br><img src="../../../../img/vue_renderFn.png" alt="vue_renderFn"><br><strong>render函数</strong>：用来生成Vnode，vue是推荐使用模板来构建我们的应用界面，但底层还是会将模板编译成render函数。跑vue项目，在浏览器查看文件，我们可以看到模板编译成render的样子。   </p>
<pre><code>var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(&quot;div&quot;, { staticClass: &quot;container&quot; }, [
    _c(&quot;div&quot;, { staticClass: &quot;seach-conaitor&quot; }, [
      _c(
        &quot;div&quot;,
        { staticClass: &quot;seach-box&quot;, staticStyle: { width: &quot;465px&quot; } },
        [
          _c(
            &quot;button&quot;,
            {
              staticClass: &quot;change_btn_bgcolor&quot;,
              on: { click: _vm.creatNewEvalution }
            },
            [_vm._v(&quot;流程&quot;)]
          ),
          _vm._v(&quot; &quot;),
          _c(&quot;input&quot;, {
            directives: [
              {
                name: &quot;model&quot;,
                rawName: &quot;v-model&quot;,
                value: _vm.searchText,
                expression: &quot;searchText&quot;
              }
            ],
            attrs: { type: &quot;text&quot;, placeholder: &quot;请输入关键字&quot; },
            domProps: { value: _vm.searchText },
            on: {
              keyup: function($event) {
                if (
                  !(&quot;button&quot; in $event) &amp;&amp;
                  _vm._k($event.keyCode, &quot;enter&quot;, 13, $event.key)
                ) {
                  return null
                }
                _vm.searchItem($event)
              },
</code></pre><p>上面被编译的就是我们的.vue文件，最终还是会被编译成这样的render函数。<br><strong>Virtual DOM</strong>:vue的虚拟Dom树。<br><strong>Diff</strong>:vue的diff算法，内部实现很复杂，算出数据变动视图需要改变的最小量，再结合patch来更新视图。<br><strong>Patch</strong>:负责把这些虚拟DOM真正施加到真实的DOM上。可以参考这位大神的文章（<img src="https://segmentfault.com/a/1190000008291645" alt="vue">）;  </p>
<h2 id="vue的渲染机制"><a href="#vue的渲染机制" class="headerlink" title="vue的渲染机制"></a>vue的渲染机制</h2><h3 id="vue的构建模式"><a href="#vue的构建模式" class="headerlink" title="vue的构建模式"></a>vue的构建模式</h3><p><strong>独立构建</strong> ：包含了模板编译器，渲染过程 HTML字符串-&gt;render()-&gt;VNode-&gt;真实的DOM节点。<br><strong>运行时构建</strong>：不包含模板编译器，渲染过程 render()-&gt;VNode-&gt;真实的DOM节点。<br>独立构建可以理解为  </p>
<p><img src="../../../../img/vue_render2.png" alt="vue_render"><br>再看下运行时构建  </p>
<p><img src="../../../../img/mount.png" alt="vue_render"><br>可以看出，在有三种渲染模式，分别是自定义的render()、template、el。<br><strong>el的写法</strong>    </p>
<pre><code>let app = new Vue({
    el:&apos;#app&apos;,
    data(){
        return{
             msg:&apos;hello world&apos;
        }
    }
})  
</code></pre><p>这个就是我们通常直接html内的写法，直接挂载到页面元素上。等级最低，如果有template或者render，el将被忽略。  </p>
<p><strong>template的写法</strong>    </p>
<pre><code>let app = new Vue({
    template:&apos;&lt;div&gt;{{msg}}&lt;/div&gt;&apos;,
    data() {
        return {
            msg: &apos;hello world&apos;
        }
    }
})
</code></pre><p>指一个字符串模板作为vue实例的标识使用。模板将会替换挂载的元素。如果render函数存在，该模板将会被忽略。  </p>
<p><strong>自定义render函数</strong>    </p>
<pre><code>Vue.component(&apos;anchored-heading&apos;,{
    render:function(createElement){
        return createElement(
            &apos;h&apos; + this.level,
               this.$slots.default
        )
    },
    props:{
        level:{
            type:Number,
            required:true
        }
    }
})
</code></pre><p>字符串模板的代替方案，允许你发挥JS最大的编程能力。该渲染函数接收一个<em>CreateElement</em>方法作为第一个参数用来创建VNode。<br>vue选项中的render函数诺存在，则vue构造函数不会从template选项或通过el选项指定的挂载元素中提取的HTML模板编译渲染函数。<br>其实这三种渲染模式最终都会得到render函数，只不过用户自定义的render函数省去了程序分析的过程，等同于处理过的render函数，而普通的template或者el只是字符，还需要解析成AST，再将AST转化成render函数。<br>官方推荐还是使用template或者el。这两种属于声明式渲染，理解容易。但对于一些逻辑复杂的需求，render用起来更方便。现在很多vue的UI插件是用render函数编写。<br><strong>CreateElement</strong><br>Vue通过建立一个虚拟DOM对真实DOM发生的变化保持追踪。    </p>
<pre><code>return createElement(&apos;h1&apos;,this.blogtitle)  
</code></pre><p>createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为“虚拟节点 (Virtual Node)”，也常简写它为“VNode”。“虚拟 DOM”是对由 Vue 组件树建立起来的整个 VNode 树的称呼。<br><em>createElement参数</em>    </p>
<pre><code>// @returns {VNode}
createElement(
  // {String | Object | Function}
  // 一个 HTML 标签字符串，组件选项对象，或者
  // 解析上述任何一种的一个 async 异步函数，必要参数。
  &apos;div&apos;,
  // 如果是函数需要返回一个Object或者String
  // {Object}
  // 一个包含模板相关属性的数据对象
  // 这样，您可以在 template 中使用这些属性。可选参数。
  {
    // data
  },

  // {String | Array}
  // 子节点 (VNodes)，由 `createElement()` 构建而成，
  // 或使用字符串来生成“文本节点”。可选参数。
  [
    &apos;先写一些文字&apos;,
    createElement(&apos;h1&apos;, &apos;一则头条&apos;),
    createElement(MyComponent, {
      props: {
        someProp: &apos;foobar&apos;
      }
    })
  ]
)
</code></pre><p>再看第二个参数，data    </p>
<pre><code>{
  // 和`v-bind:class`一样的 API
  // 接收一个字符串、对象或字符串和对象组成的数组
  &apos;class&apos;: {
    foo: true,
    bar: false
  },
  // 和`v-bind:style`一样的 API
  // 接收一个字符串、对象或对象组成的数组
  style: {
    color: &apos;red&apos;,
    fontSize: &apos;14px&apos;
  },
  // 正常的 HTML 特性
  attrs: {
    id: &apos;foo&apos;
  },
  // 组件 props
  props: {
    myProp: &apos;bar&apos;
  },
  // DOM 属性
  domProps: {
    innerHTML: &apos;baz&apos;
  },
  // 事件监听器基于 `on`
  // 所以不再支持如 `v-on:keyup.enter` 修饰器
  // 需要手动匹配 keyCode。
  on: {
    click: this.clickHandler
  },
  // 仅对于组件，用于监听原生事件，而不是组件内部使用
  // `vm.$emit` 触发的事件。
  nativeOn: {
    click: this.nativeClickHandler
  },
  // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`
  // 赋值，因为 Vue 已经自动为你进行了同步。
  directives: [
    {
      name: &apos;my-custom-directive&apos;,
      value: &apos;2&apos;,
      expression: &apos;1 + 1&apos;,
      arg: &apos;foo&apos;,
      modifiers: {
        bar: true
      }
    }
  ],
  // 作用域插槽格式
  // { name: props =&gt; VNode | Array&lt;VNode&gt; }
  scopedSlots: {
    default: props =&gt; createElement(&apos;span&apos;, props.text)
  },
  // 如果组件是其他组件的子组件，需为插槽指定名称
  slot: &apos;name-of-slot&apos;,
  // 其他特殊顶层属性
  key: &apos;myKey&apos;,
  ref: &apos;myRef&apos;
}
</code></pre><p>这个官方的表述已经很清楚了。如果使用render函数来渲染，v-model，v-if这样的指令都需要自己定义。可以在render函数中封装一些自己业务需要的指令。<br>比较一下<code>template</code>和<code>render</code>创建一个相同的组件    </p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
     &lt;custom-element&gt;&lt;/custom-element&gt; 
&lt;/div&gt; 
Vue.component(&apos;custom-element&apos;, 
    { template: `&lt;div id=&quot;box&quot; :class=&quot;{show: show}&quot;@click=&quot;handleClick&quot;&gt;Hello Vue!&lt;/div&gt;`,
    data () {
       return { 
            show: true
       }
     },
     methods: {
         handleClick: function () { 
                console.log(&apos;Click!&apos;) 
            }
     } 
})
</code></pre><p><code>render</code>    </p>
<pre><code>Vue.component(&apos;custom-element&apos;, {
    render: function(createElement) {
        return createElement(&apos;div&apos;, {
            class: {
                show: this.show
            },
            attrs: {
                id: &apos;box&apos;
            },
            on: {
                click: this.handleClick
            }
        }, &apos;Hello Vue!&apos;)
    },
    data() {
        return {
            show: true
        }
    },
    methods: {
        handleClick: function() {
            console.log(&apos;Click!&apos;)
        }
    }
})
</code></pre><p>再声明一个Vue实例，并挂载到真实DOM上    </p>
<pre><code>let app = new Vue({
    el: &apos;#app&apos;
})  
</code></pre><p>这样就很好理解了，render函数不需要编译生成AST。<br>render函数结合上面我们给的数据直接生成vitual DOM,再由vue的diff和patch映射到真实DOM上，跟新视图。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fishluo1992.github.io/2018/06/01/vue的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="没尾巴的鱼">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/img_1.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fish_need_sea">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/vue的理解/" itemprop="url">Vue的MVVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-01T00:00:00+08:00">
                2018-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>人生时苦，所以要做一个简单的人，<br>常想一二，不思八九，<br>越活越带感。  </p>
<h2 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h2><p>用过vue写过项目或者看过vue的同学在被问到“vue的响应式原理时”可能都会直接说：  Vue 是通过Object.defineProperty方法把data对象的全部属性转化成getter/setter，当属性被访问或者被修改时通知变化。  </p>
<p>Object.defineProperty的API的定义？这个就是ES5改变属性的值的一个API！这么回答肯定是有问题的，MDN的定义是：<br><em>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</em><br>再看vue官网介绍的响应式原理图。<br><img src="../../../../img/vue_prototype.jpg" alt="vue"><br> 首先通过渲染触发了Data的getter进行依赖收集，源码里有个一Deps订阅者，在数据变化时会通知所有的Watcher观察者，也就是说，在data变化时会触发它的setter，setter通知Watcher，Watcher通知组件执行Render Function，函数内再根据diff算法来实现视图的更新（render函数会根据内部的VNode，也就是vue的虚拟DOM生成DOM树，diff就是新VNode节点与旧VNode节点进行深度对比(vue源码是比较新旧两个列表的vm的数据状态)，算出施加到真实DOM上最小的改动，然后更新视图）。  </p>
<h2 id="vue的MVVM实现"><a href="#vue的MVVM实现" class="headerlink" title="vue的MVVM实现"></a>vue的MVVM实现</h2><p>再分析vue的MVVM的实现  </p>
<p><img src="../../../../img/vue_mvvm.png" alt="vue_mvvm"><br>      new MVVM()也就是构造函数Vue的实例 new Vue()，是Vue的入口函数。<br>      Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可以通知订阅者。<br>      Watcher 订阅者，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。<br>      Compile 指令解析器，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据和绑定相应的更新数据。<br>      Dep 消息订阅器，Observer内部维护的一个数组，用来收集订阅者Wacher，数据变动触发notify函数，再调用订阅者的update方法。  </p>
<h3 id="new-MVVM"><a href="#new-MVVM" class="headerlink" title="new MVVM()"></a>new MVVM()</h3><p>先看vue的<a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L107" target="_blank" rel="noopener">initData</a> 这个就是new Vue内初始化的数据，内部将数据进行Observer监听数据变化。    </p>
<pre><code>/*初始化data*/
function initData (vm: Component) {

  /*得到data数据*/
  let data = vm.$options.data
  data = vm._data = typeof data === &apos;function&apos;
    ? getData(data, vm)
    : data || {}

  /*对对象类型进行严格检查，只有当对象是纯javascript对象的时候返回true*/
  if (!isPlainObject(data)) {
data = {}
process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(
  &apos;data functions should return an object:\n&apos; +
  &apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;,
  vm
)
}
  // proxy data on instance
  /*遍历data对象*/
  const keys = Object.keys(data)
  const props = vm.$options.props
  let i = keys.length

  //遍历data中的数据
  while (i--) {

/*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/
if (props &amp;&amp; hasOwn(props, keys[i])) {
  process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(
    `The data property &quot;${keys[i]}&quot; is already declared as a prop. ` +
    `Use prop default value instead.`,
    vm
  )
} else if (!isReserved(keys[i])) {
  /*判断是否是保留字段*/

  /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/
  proxy(vm, `_data`, keys[i])
}
      }
      // observe data
      /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/
      observe(data, true /* asRootData */)
    }

    function getData (data: Function, vm: Component): any {
      try {
        return data.call(vm)
      } catch (e) {
        handleError(e, vm, `data()`)
        return {}
      }
    }    
</code></pre><p>内部的实现还是很复杂的，再说说proxy函数。     </p>
<pre><code>export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
</code></pre><p>代理函数，实现数据代理，<code>vm.options -&gt; vm._data.options</code>，可以理解为;     </p>
<pre><code>proxy: function(key, setter, getter) {
    var me = this;
    setter = setter || 
    Object.defineProperty(_vm, key, {
        configurable: false, //不能再define定义
        enumerable: true,
        get: function proxyGetter() {
            return _vm._data[key];
        },
        set: function proxySetter(newVal) {
            _vm._data[key] = newVal;
        }
    });
},
</code></pre><h3 id="Observer监听者"><a href="#Observer监听者" class="headerlink" title="Observer监听者"></a>Observer监听者</h3><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L34" target="_blank" rel="noopener">Oberver</a>的作用就是遍历对象的属性进行双向绑定。    </p>
<pre><code>export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that has this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0

    /*
    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16
    */
    def(value, &apos;__ob__&apos;, this)
    if (Array.isArray(value)) {

      /*
          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。
          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。
      */
      const augment = hasProto
        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/
        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/
      augment(value, arrayMethods, arrayKeys)
      /*Github:https://github.com/answershuto*/
      /*如果是数组则需要遍历数组的每一个成员进行observe*/
      this.observeArray(value)
    } else {

      /*如果是对象则直接walk进行绑定*/
      this.walk(value)
    }
  }

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)

    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array&lt;any&gt;) {

    /*数组需要便利每一个成员进行observe*/
    for (let i = 0, l = items.length; i &lt; l; i++) {
      observe(items[i])
    }
  }
}
</code></pre><p>defineReactive作用是通过defineProperty给数据定义getter\setter，当数据变动时通知Deps订阅器，映射给Watcher观察者对视图做变更。</p>
<pre><code>Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) {
        customSetter()
      }
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
        // 如果是新值并且是object的话就进行监听
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify() // 通知订阅者
    }
  })  
</code></pre><h3 id="Deps订阅器"><a href="#Deps订阅器" class="headerlink" title="Deps订阅器"></a>Deps订阅器</h3><p>Deps订阅器的实现可以简单这样理解，就是数组subs  ，可以订阅多个观察者，依赖收集后Deps也会存在多个Watcher对象，在数据变更时通知所有的Watcher。</p>
<pre><code>var uid = 0;

function Dep() {
    this.id = uid++;
    this.subs = []; // 这个就是订阅器
}

Dep.prototype = {
    addSub: function(sub) {
        this.subs.push(sub);
    },

    depend: function() {
        Dep.target.addDep(this);
    },

    removeSub: function(sub) {
        var index = this.subs.indexOf(sub);
        if (index != -1) {
            this.subs.splice(index, 1);
        }
    },

    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update();  // 视图局部更新 subs[index]
        });
    }
};
</code></pre><h3 id="Watcher-观察者"><a href="#Watcher-观察者" class="headerlink" title="Watcher 观察者"></a>Watcher 观察者</h3><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js#L24" target="_blank" rel="noopener">Watcher</a>就是一个观察对象，依赖收集以后Watcher对象会被保存在Deps中。    </p>
<pre><code>export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array&lt;Dep&gt;;
  newDeps: Array&lt;Dep&gt;;
  depIds: ISet;
  newDepIds: ISet;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: Object
  ) {
    this.vm = vm
    /*_watchers存放订阅者实例*/
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.lazy // for lazy watchers
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== &apos;production&apos;
      ? expOrFn.toString()
      : &apos;&apos;
    // parse expression for getter
    /*把表达式expOrFn解析成getter*/
    if (typeof expOrFn === &apos;function&apos;) {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = function () {}
        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(
          `Failed watching path: &quot;${expOrFn}&quot; ` +
          &apos;Watcher only accepts simple dot-delimited paths. &apos; +
          &apos;For full control, use a function instead.&apos;,
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
   /*获得getter的值并且重新进行依赖收集*/
  get () {
    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/
    pushTarget(this)
    let value
    const vm = this.vm

    /*
      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。
      在将Dep.target设置为自生观察者实例以后，执行getter操作。
      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，
      那么在执行getter的时候就会触发a跟c两个数据的getter函数，
      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，
      将该观察者对象放入闭包中的Dep的subs中去。
    */
    if (this.user) {
      try {
        value = this.getter.call(vm, vm)
      } catch (e) {
        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)
      }
    } else {
      value = this.getter.call(vm, vm)
    }
    // &quot;touch&quot; every property so they are all tracked as
    // dependencies for deep watching
    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/
    if (this.deep) {
      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/
      traverse(value)
    }

    /*将观察者实例从target栈中取出并设置给Dep.target*/
    popTarget()
    this.cleanupDeps()
    return value
  }

  /**
   * Add a dependency to this directive.
   */
   /*添加一个依赖关系到Deps集合中*/
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  /**
   * Clean up for dependency collection.
   */
   /*清理依赖收集*/
  cleanupDeps () {
    /*移除所有观察者对象*/
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
   /*
      调度者接口，当依赖发生改变的时候进行回调。
   */
  update () {
    /* istanbul ignore else */
     // 1. 每次调用run()的时候会触发相应属性的getter
    // getter里面会触发dep.depend()，继而触发这里的addDep
    // 2. 假如相应属性的dep.id已经在当前watcher的depIds里，说明不是一个新的属性，仅仅是改变了其值而已
    // 则不需要将当前watcher添加到该属性的dep里
    // 3. 假如相应属性是新的属性，则将当前watcher添加到新属性的dep里
    // 如通过 vm.child = {name: &apos;a&apos;} 改变了 child.name 的值，child.name 就是个新属性
    // 则需要将当前watcher(child.name)加入到新的 child.name 的dep里
    // 因为此时 child.name 是个新值，之前的 setter、dep 都已经失效，如果不把 watcher 加入到新的 child.name 的dep中
    // 通过 child.name = xxx 赋值的时候，对应的 watcher 就收不到通知，等于失效了
    // 4. 每个子属性的watcher在添加到子属性的dep的同时，也会添加到父属性的dep
    // 监听子属性的同时监听父属性的变更，这样，父属性改变时，子属性的watcher也能收到通知进行update
    // 这一步是在 this.get() --&gt; this.getVMVal() 里面完成，forEach时会从父级开始取值，间接调用了它的getter
    // 触发了addDep(), 在整个forEach过程，当前wacher都会加入到每个父级过程属性的dep
    // 例如：当前watcher的是&apos;child.child.name&apos;, 那么child, child.child, child.child.name这三个属性的dep都会加入当前watcher
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      /*同步则执行run直接渲染视图*/
      this.run()
    } else {
      /*异步推送到观察者队列中，由调度者调用。*/
      queueWatcher(this)
    }
  }

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
   /*
      调度者工作接口，将被调度者回调。
    */
  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        /*
            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。
        */
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        /*设置新的值*/
        this.value = value

        /*触发回调渲染视图*/
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
   /*获取观察者的值*/
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   */
   /*收集该watcher的所有deps依赖*/
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  /**
   * Remove self from all dependencies&apos; subscriber list.
   */
   /*将自身从所有依赖收集订阅列表删除*/
  teardown () {
    if (this.active) {
      // remove self from vm&apos;s watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this)
      }
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
    }
  }
}
</code></pre><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p><a href="https://github.com/vuejs/vue/blob/dev/src/compiler/parser/index.js" target="_blank" rel="noopener">Compile</a>也就是指令解析器，这个和一般的模板引擎的区别都不大，大部分通过正则判断内部指令（普通指令和事件指令）。这个就简单说道这里。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要学到精髓还得多看看源码，看完也可以学到很多。整体架构，逻辑API的依赖等还需要仔细理解学习。<br>多看源码就对了。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fishluo1992.github.io/2018/05/31/vue的小坑one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="没尾巴的鱼">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/img_1.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fish_need_sea">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/vue的小坑one/" itemprop="url">奇怪的流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T19:47:45+08:00">
                2018-05-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p>  这是上一个项目了，公司内部的OA系统，页面近30个了，由我这个前端和一个java大神完成。总体时间也近两个月，接口的调试时间也占了很多，因为数据逻辑的耦合度太高了。<br>  下面谈谈一其中的个小需求吧！看图！  </p>
<p>  <img src="../../../../img/project_1.png" alt="js原型链"><br>  就是这种审批流程图，看起来比一般的线流程图多了一点样式。因为项目的模块不少，每个模块都有不同的审批流程，像这样  </p>
<p>   <img src="../../../../img/project_2.png" alt="js原型链">  </p>
<h2 id="解剖一下"><a href="#解剖一下" class="headerlink" title="解剖一下"></a>解剖一下</h2><p>   每个模块多个流程都需要看到这个流程走向，图像的上面是一个显示详细审批的信息列表。因为每个模块的流程图都不同，所有只能每个模块封装一个独有的组件来分别显示。 数据直接父组件传给子组件。 </p>
<p> <em>思考</em><br>  看到这样的设计图，直接简单粗暴的分析下。<br>  流程的显示有三种，分别是未开始、已处理和下一步处理，另外还有个驳回箭头。<br>  1.一般来讲，我们首先想到的会是用canvas来控制几种样式的逻辑<br>  2.另外还可以用JS+CSS来控制。  </p>
<p>   <em>动手</em><br> 嗯，canvas貌似也不错，在花了一个多小时画完这个图后，瞅瞅代码，这什么鬼。代码上百行，还没加逻辑判断，连自己看不下去了。再试试下个方案吧。<br> vue,可以类似JSP页面，HTML可以嵌套JS。那么逻辑控制显示就没问题了。那就得先把图画好了，圆和条子很简单，箭头也直接border画个三角形就OK了，不正规的菱形？两个三角形对立就OK了。  </p>
<pre><code>border-top: 5px solid transparent;
border-bottom: 5px solid transparent;
border-left: 5px solid #878787;  
</code></pre><p>对的，就是这样。  </p>
<p><em>逻辑和数据处理</em><br>UI界面的图就这样完美出来了，是不难吧。嗯，只是开始。后台给我的接口只有一个数据seq来控制整个流程。对的，只有一个seq！！！ 我这边需要控制每个步骤图的三种不同的显示和驳回箭头的显示。   </p>
<p>嗯，不难，真的。只是多了点判断，像这样。  </p>
<pre><code> if(res.data.data.length &gt; 1 &amp;&amp; index == res.data.data.length-1){
    if(arr[index].seq &lt; arr[index-1].seq){
        if(arr[index-1].seq == 2){
            that.ctrl = {&quot;step&quot;:Number(item.seq)-1,&quot;stop&quot;:1}
        }else if(arr[index-1].seq == 5){
            that.ctrl = {&quot;step&quot;:Number(item.seq)-1,&quot;stop&quot;:2}
        }else if(arr[index-1].seq == 6){
            that.ctrl = {&quot;step&quot;:Number(item.seq)-1,&quot;stop&quot;:3}
        }else{
            that.ctrl = {&quot;step&quot;:8,&quot;stop&quot;:0}
        }            
    }else{
        that.ctrl = {&quot;step&quot;:Number(item.seq),&quot;stop&quot;:0}
    }    
}else{
    that.ctrl = {&quot;step&quot;:1,&quot;stop&quot;:0}
}
</code></pre><p>最终直接把ctrl传给子组件，参数是step和驳回的stop。那么接下来就是子组件控制流程的样式了，对的，这个也不难。<br>先取到数据  </p>
<pre><code>watch:{
     ctrl:function(newval,oldval){
             if(newval != oldval){
                 this.getData()
             }
         }
 },
 props:{
     ctrl:{
         type:Object,
         default:function(){
             return {};
         }
     }
 }
</code></pre><p>因为一个模块内的每个流程都需要这个显示，所有需要watch一下保证数据完美的显示。  </p>
<h2 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h2><p>数据有了，基本页面也完美展示了，那通过数据该咋渲染呢？<br>嗯，这个也不难。用来控制Class来控制就好，像这样  </p>
<pre><code>:class=&quot;step_t?&apos;ctrl-step-rebut&apos;:&apos;&apos;&quot;   
</code></pre><p>是的这样可以控制两种，那这里有三种咋控制呢？这样？  </p>
<pre><code>:class=&quot;stepTwo?&apos;ctrl-first-right-writhe&apos;:(stepOne?&apos;ctrl-first-right-son&apos;:&apos;&apos;)&quot;  
</code></pre><p>对的，就是这样，理论上三元表达式可以无限叠，但一般不会这样，万一其他人来维护这个项目呢，那不直接带刀找你了，所有两层就可以了，多层用if elseif来判断。<br>这样就可以完美的控制三种显示了。step 和 stop 也需要处理  </p>
<pre><code>switch (this.ctrl.step)
           {
               case 1: 
                ...
                break; 
               case 2:
                ...
                break;  
               case 3:
                ...
                break;
            }  

  switch (this.ctrl.stop){...}  
</code></pre><p> 就这样，直接判断出流程走到哪一步，直接再通过显示哪里class来显示对应的样式就可以了。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.相比canvas来讲，用JS+css来解决这样流图更好，代码没那么复杂，能一看就懂，样式和一些逻辑也可以复用，清晰易懂。<br>2.业务都不难，难的是对底层代码的理解和自己实现业务逻辑的方法。每次碰到带点逻辑的业务还是需要仔细分析，保证自己能做到自己能做到的极限。<br>3.vue用起来还是很爽的，下一篇博客也来讲讲自己对vue的理解吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fishluo1992.github.io/2018/05/28/原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="没尾巴的鱼">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/img_1.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fish_need_sea">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/原型链/" itemprop="url">原型链的继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T18:33:28+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原型链图-先上图"><a href="#原型链图-先上图" class="headerlink" title="原型链图(先上图)"></a>原型链图(先上图)</h2><p><img src="../../../../img/prototype_img.png" alt="js原型链">  </p>
<p>图片网上找的…</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="原型链的继承"><a href="#原型链的继承" class="headerlink" title="原型链的继承"></a>原型链的继承</h3><p>大家都知道面向对象有三大基本特性 ：封装、继承、多态。<br>继承是指让某个类型的对象获得另一个类型的对象的属性和方法。<br>而原型和原型链是Javascript实现继承的一种模型。<br>原型链的基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。<br>Javascript在创建对象的时候，都有一个叫做<strong>proto</strong>的内置属性，用于指向创建它的构造函数的原型对象，也就是图片上的prototype（这个属性指向原型对象，只有函数才有）。<br>每个对象都有<code>__proto__</code>属性，指向所继承的上层对象，最顶级是null;<br>从图上看，可以看到null的上一个指针是指向Object.prototype,也就是说,可以把Object看做是一个构造函数(其实它就是一个内置的构造函数)，其他的方法就是基于这个类型继承而来的。<br><code>var a = [];//这个同等于 var a = new Array();    
    var b = {}; // 同等于 var b = new Object();    
    console.log(a.__proto__ === Array.prototype) // true    
    console.log(b.__proto__ === Object.prototype) // true</code><br>我们发现a和b都有<code>__proto__</code>，分别指向了Array.prototype和Object.prototype。其实a,b都是内置的构造函数的实例对象，都基于类型分别继承了构造函数的prtotype。 </p>
<p>平常写的时候感觉很正常，其实像Array、Object这样的函数内置对象还有 Date、Function、RegExp、Json、Math。 </p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>只要创建一个新函数，就会根据规则给这个函数创建一个prototype属性，这个属性指向函数的原型对象。<br>也可以这样理解，所有函数对象都指向Function.prototype，都是Function的实例。<br><code>function Fn(){}  console.log(Fn.__proto__ === Function.prototype) //true</code><br>也就是说，<code>__proto__</code>存在于实例与构造函数原型对象之间，而不是存在于实例与构造函数之间。也可以理解为原型链的形成主要还是看<code>__proto__</code>，而不是prototype。<br>趁项目做完，忙里偷闲弄下博客（以前的总结都在txt里，哈哈）。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/img_1.png"
                alt="没尾巴的鱼" />
            
              <p class="site-author-name" itemprop="name">没尾巴的鱼</p>
              <p class="site-description motion-element" itemprop="description">Living Thinking Programming</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sea Is My World</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body>
</html>
